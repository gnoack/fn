(defn pprint (item)
  ;; TODO: Stack printing.
  ;; TODO: Optimize memory consumption for string concatenation?
  (defn string-char-escape (ch)
    ;; TODO: Some cases are missing.
    (cond ((eq? ch #\") "\\\"")
          ((eq? ch #\Newline) "\\n")
          ((eq? ch #\Tab) "\\t")
          (true (list->string (list ch)))))
  (defn literal-char-escape (ch)
    (cond ((eq? ch #\Newline) "Newline")
          ((eq? ch #\Tab) "Tab")
          ((eq? ch #\Space) "Space")
          (true (list->string (list ch)))))
  (defn pprint-kv-pair (kv)
    (string-append (pprint (first kv)) ": " (pprint (rest kv))))
  (defn pprint-inner-list (l)
    (cond ((nil? l) "")
          ((cons? l) (if (nil? (rest l))
                         (pprint (first l))
                       (string-append (pprint (first l)) " "
                                      (pprint-inner-list (rest l)))))
          (true (string-append ". " (pprint l)))))
  ;; TODO: Rewrite with typecase
  (cond ((string? item) (string-append "\""
                                       (apply string-append
                                              (map string-char-escape
                                                   (string->list item)))
                                       "\""))
        ((dict? item)
         (string-append "#{"
                        (string-join (map pprint-kv-pair
                                          (dict-key-value-pairs item))
                                     ", ")
                        "}"))
        ((array? item)
         (string-append "#["
                        (string-join (map pprint (array->list item)) ", ")
                        "]"))
        ((mem-block? item) "#<MEM-BLOCK>")
        ((cons? item)
         (if (and (eq? 'quote (first item))
                  (= 2 (length item)))
             (string-append "'" (pprint (second item)))
           (string-append "(" (pprint-inner-list item) ")")))
        ((native-procedure? item)
         (string-append "<NATIVE-PROCEDURE "
                        (pprint (procedure-name item)) ">"))
        ((lisp-procedure? item)
         (string-append "<PROCEDURE " (pprint (procedure-name item))
                        " " (pprint (lisp-procedure-lambda-list item)) ">"))
        ((compiled-procedure? item)
         (string-append "<COMPILED-PROCEDURE " (pprint (procedure-name item))
                        " " (pprint (lisp-procedure-lambda-list item)) ">"))
        ((char? item)   (string-append "#\\" (literal-char-escape item)))
        ((number? item) (int->string item 10))
        ((nil? item)    "()")
        ((symbol? item) (symbol->string item))
        ((type? item)   (string-append "#<TYPE "
                                       (type-name item)
                                       ">"))
        ((eq? true item) "true")
        ((eq? false item) "false")
        ((has-method?
          item 'pprint) (send item 'pprint))
        ((mem? item)    "#<OBJECT>")
        (true           "?UNPRINTABLE?")))

(defn display (item)
  (if (string? item)
      (writeout item)
    (writeout (pprint item))))

(defn println (&rest args)
  (map display args)
  (writeout "\n")
  nil)

;; TODO: Rather implement stack traces in C, for robustness!
;; TODO: Break dependency on this.
(defn frame-caller (f) ($mem-get f 2))
(defn frame-procedure (f) ($mem-get f 3))
(defn dframe-caller (f) ($mem-get f 3))
(defn dframe-procedure (f) ($mem-get f 4))

(defn print-stack-trace (frame)
  (typecase frame
    ((@Frame)  (progn
                 (println " - " (frame-procedure frame))
                 (print-stack-trace (frame-caller frame))))
    ((@Dframe) (progn
                 (println " - " (dframe-procedure frame))
                 (print-stack-trace (dframe-caller frame))))
    (else nil)))
