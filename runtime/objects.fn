;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Types                                                          ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(def Object ($make 1 2 3 4))
; Type is set below, Object and Type refer to each other.
($mem-set! Object 1 (make-dict))
($mem-set! Object 2 "Object")
($mem-set! Object 3 nil) ; supertype

;; TODO: Type is really "Object class".
;; The type Type links to itself: Type = ($make Type (make-dict) "Type")
(def Type ($make 1 2 3 4))
($mem-set! Type 0 Type)
($mem-set! Type 1 (make-dict))
($mem-set! Type 2 "Type")
($mem-set! Type 3 Object)

(defn type-name (type) ($mem-get type 2))
(defn type-superclass (type) ($mem-get type 3))
(defn type? (x)
  (or
   (eq? (type-of x) Type)
   (type? (type-of x))))

; Close the loop.
($mem-set! Object 0 Type)


(defn $bolt-on-metaclass! (type)
  (let ((metaclass
         ($make Type (make-dict)
                (string-append (type-name type) " class")
                ($mem-get (type-superclass type) 0))))
    ($mem-set! type 0 metaclass)))

; Cons and others must be created early for object creation from C,
; so we need some retroactive patching.  Idea is still this:
;  (def Cons ($make Type (make-dict)))
(defn $patch-type! (type name)
  ($mem-set! type 0 Type)  ; not needed?
  ($mem-set! type 1 (make-dict))
  ($mem-set! type 2 name)
  ($mem-set! type 3 Object)
  ($bolt-on-metaclass! type))

;; TODO: Refactor duplication in strings and symbols.
($patch-type! Array "Array")
($patch-type! Cons "Cons")
($patch-type! Continuation "Continuation")
($patch-type! Dframe "Dframe")
($patch-type! Dict "Dict")
($patch-type! Frame "Frame")
($patch-type! Stack "Stack")
($patch-type! String "String")
($patch-type! Symbol "Symbol")
;; TODO: Bool and false should share a common supertype.
($patch-type! True "True")
($patch-type! False "False")

; Same procedure for Procedure.
($patch-type! Procedure "Procedure")
($patch-type! NativeProcedure "NativeProcedure")
($patch-type! CompiledProcedure "CompiledProcedure")

(defn make-type (name supertype)
  (let ((result ($make Type (make-dict) name supertype)))
    ($bolt-on-metaclass! result)
    result))

(defmacro deftype (name)
  `(def ,name (make-type ,(symbol->string name) Object)))

(deftype Smallint)
(deftype Character)
(deftype Nil)
(deftype MemBlock)

(defn dict? (obj)
  (eq? (type-of obj) Dict))

;; Hardcoded for half-primitive values like integers,
;; characters, nil and so forth.  For higher-level,
;; memory-allocated values, the value at position 0
;; is used as type.
(defn type-of (x)
  (cond ((number? x) Smallint)
	((char? x) Character)
	((nil? x) Nil)
        ((mem-block? x) MemBlock)
	((mem? x) ($mem-get x 0))))

;;; Method definition

(defn install-method! (type selector method)
  (assert (type? type))
  (dict-put! ($mem-get type 1) selector method))

(defmacro defm (type selector args &rest body)
  `(install-method! ,type ,selector
                    (lambda (self ,@args) ,@body)))


;;; Message sending

(defn send (receiver message &rest arguments)
  (defn %method-for-type (type selector)
    (dict-get ($mem-get type 1) selector))
  (if (procedure? receiver)
      (apply receiver (cons message arguments))
      (apply (%method-for-type (type-of receiver) message)
             (cons receiver arguments))))

(defn has-method? (receiver selector)
  ;; Limitation: Only works for proper objects, not for functions.
  (and (not (procedure? receiver))
       (dict-has-key? ($mem-get (type-of receiver) 1)
                      selector)))

;; Like apply, but for sending messages.
(defn send-apply (receiver message arguments)
  (apply send (cons receiver (cons message arguments))))

(defn sender (message)
  (lambda (receiver &rest args)
    (send-apply receiver message args)))
