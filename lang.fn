(

(def not (lambda (a)
	   (if a false true)))

(def _and (lambda (a b)
	   (if a b false)))

(def _or (lambda (a b)
	  (if a true b)))

;; Nil?
(def nil? (lambda (x)
	    (eq nil x)))

;; Map
(def map (lambda (proc sequence)
	   (if (nil? sequence)
	       sequence
	       (cons (proc (first sequence))
		     (map proc (rest sequence))))))

;; Reduce
(def reduce (lambda (proc list start)
	      (if (nil? list)
		  start
		  (reduce proc
			  (rest list)
			  (proc start (first list))))))

;; Reversing sequences.
(def %xcons (lambda (l r)
	     (cons r l)))

(def reverse (lambda (seq)
	       (reduce %xcons seq nil)))

;; Association lists.
(def acons
    (lambda (key value list)
      (cons (cons key value) list)))

(def lookup
    (lambda (key alist)
      (if (nil? alist)
	  false
	  (if (eq key (first (first alist)))
	      (rest (first alist))
	      (lookup key (rest alist))))))

(def pairlis
    (lambda (keys values)
      (if (_or (nil? keys)
	       (nil? values))
	  '()
	  (acons (first keys)
		 (first values)
		 (pairlis (rest keys) (rest values))))))

;; cons, cons?
(def cons
    (lambda (car cdr)	
      ($make @cons car cdr)))

(def %has-mem-type?
  (lambda (value type)
    (if (mem? value)
        (eq type ($mem-get value 0))
      false)))

(def cons?
  (lambda (value) (%has-mem-type? value @cons)))

(def native-procedure?
  (lambda (proc) (%has-mem-type? proc @native-procedure)))

(def lisp-procedure?
  (lambda (proc) (%has-mem-type? proc @procedure)))

(def procedure?
  (lambda (proc)
    (_or (native-procedure? proc)
         (lisp-procedure? proc))))

;; See procedures.c for what fields mean what.
(def procedure-name (lambda (proc) ($mem-get proc 1)))
(def lisp-procedure-lambda-list (lambda (proc) ($mem-get proc 2)))

)
