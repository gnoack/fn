(

(def not (lambda (a)
	   (if a false true)))

(def _and (lambda (a b)
	   (if a b false)))

(def _or (lambda (a b)
	  (if a true b)))

;; Nil?
(def nil? (lambda (x)
	    (eq nil x)))

;; Map
(def map (lambda (proc sequence)
	   (if (nil? sequence)
	       sequence
	       (cons (proc (first sequence))
		     (map proc (rest sequence))))))

(def reduce (lambda (proc list start)
	      (if (nil? list)
		  start
		  (reduce proc
			  (rest list)
			  (proc start (first list))))))

;; Association lists.
(def acons
    (lambda (key value list)
      (cons (cons key value) list)))

(def lookup
    (lambda (key alist)
      (if (nil? alist)
	  false
	  (if (eq key (first (first alist)))
	      (rest (first alist))
	      (lookup key (rest alist))))))

(def pairlis
    (lambda (keys values)
      (if (_or (nil? keys)
	       (nil? values))
	  '()
	  (acons (first keys)
		 (first values)
		 (pairlis (rest keys) (rest values))))))

;; cons, cons?
(def cons
    (lambda (car cdr)	
      ($make @cons car cdr)))

(def cons?
    (lambda (value)
      (if (mem? value)
	  (eq @cons ($get value 0))
	  false)))
)