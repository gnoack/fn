
(load-file "examples/grammar-utils.fn")
(def smalltalk-grammar (load-grammar! "examples/smalltalk.g"))
(set! smalltalk-grammar (smalltalk-grammar base-grammar))

(defmacro st-body (varnames &rest body)
  `(let ,(map (lambda (varname) `(,varname nil))
              varnames)
     ,@body))

; TODO: Solve non-local returns!
(defmacro st-return (e) e)

(defn msg-send (receiver message &rest arguments)
  ;(println "Send " message " to " receiver)
  (defn %method-for-type (type selector)
    (if (dict-has-key ($mem-get type 1) selector)
        (dict-get ($mem-get type 1) selector)
      (dict-get ($mem-get @Object 1) selector)))
  (apply (%method-for-type (type-of receiver) message)
         (cons receiver arguments)))

(defm @CompiledProcedure 'value () (self))
(defm @CompiledProcedure 'value: (a) (self a))
(defm @CompiledProcedure 'value:value: (a b) (self a b))
(defm @CompiledProcedure 'value:value:value: (a b c) (self a b c))
(defm @CompiledProcedure 'onError: (aHandler)
  (catch self aHandler))

(defmacro st-defm (type sel vars body)
  `(defm ,type (quote ,sel) ,vars
     ,body))

(defm @Smallint '+ (other)
  (+ self other))

(defm @Smallint '< (other)
  (< self other))

(defm @Smallint '> (other)
  (< other self))

(defm @Smallint '= (other)
  (= self other))

(defm @Dict 'keyValuePairs ()
  (dict-key-value-pairs self))

(defm @String 'println ()
  (println self))

(defm @String 'length ()
  (string-size self))

(defm @String '++ (other)
  (string-append self other))
  
(defm @Symbol 'asString ()
  (symbol->string self))

(defm @Cons 'println ()
  (println self))

(def expressions
 ((read-and-check-empty-remainder (@@ smalltalk-grammar file))
  (file->string "examples/st.st")))

(deftype @Smalltalk)
(def Smalltalk ($make @Smalltalk))
(defm @Smalltalk 'object:at: (obj pos)
  ($mem-get obj pos))
(defm @Smalltalk 'send:to: (sel recv)
  (msg-send recv sel))
(defm @Smalltalk 'typeOf: (obj)
  (type-of obj))
(defm @Smalltalk 'println: (obj)
  (println obj))

;; Should be a constructor on @cons.
(defm @Smalltalk 'cons:and: (car cdr)
  (cons car cdr))

(defm @Smalltalk 'eval: (str)
  (eval ((read-and-check-empty-remainder (@@ smalltalk-grammar statement)) str)))

(load-file "repl/c-loader.fn")
(load-c-module "repl/readline.so" "init_readline")

(defm @Smalltalk 'readline: (prompt)
  (readline prompt))

(deftype @Main)
(def *main* ($make @Main *args*))

(map (lambda (ex)
       ;(println ex)
       (eval ex))
     expressions)

;(println "Result: " res)

(send *main* 'main)
