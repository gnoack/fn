
(

;; Accessing elements in lists.
(defn list-index-of (list value)
  (with-asserts ((cons? list))
    (if (eq value (first list))
        0
      (+ 1 (list-index-of (rest list) value)))))

(defn list-contains? (list value)
  (if (cons? list)
      (or (eq value (first list))
          (list-contains? (rest list) value))
      false))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Static variable environments                                  ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn %globalop (op)
  (case op
    ((write-var) 'write-global-var)
    ((read-var)  'read-global-var)
    (else        (error "Unknown variable access mode: " op))))

(def global-env
  (dispatcher self
    ('prettyprint ()                "GLOBAL")

    ;; Construction
    ('linked-with-vars (vars)       (linked-env-with-vars self vars))

    ;; Code generation
    ('generate-access (depth op x)  `((,(%globalop op) ,x)))
    ('generate-read (x)             (send self 'generate-access 0 'read-var x))
    ('generate-write (x)            (send self 'generate-access 0 'write-var x))))

(defn linked-env-with-vars (next-env my-vars)
  (dispatcher self
    ('prettyprint ()                (string-append (pprint my-vars) "::"
                                                   (send next-env 'prettyprint)))

    ;; Construction
    ('linked-with-vars (vars)       (linked-env-with-vars self vars))

    ;; Code generation
    ('generate-access (depth op x)  (if (list-contains? my-vars x)
                                        `((,op ,depth ,(list-index-of my-vars x)))
                                      (send next-env 'generate-access (+ 1 depth) op x)))
    ('generate-read (x)             (send self 'generate-access 0 'read-var x))
    ('generate-write (x)            (send self 'generate-access 0 'write-var x))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Compiler                                                      ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn compile-if ((if_ condition-expr consequent-expr alternative-expr)
                  environment call-style)
  (with-gensyms (true-branch after-if)
    `(,@(compile condition-expr environment 'call)
      (pop)
      (jump-if-true ,true-branch)
      ,@(compile alternative-expr environment call-style)
      (jump ,after-if)
      (label ,true-branch)
      ,@(compile consequent-expr environment call-style)
      (label ,after-if))))

(defn compile-application (expr environment call-style)
  (when (nil? expr)
    (error "Need at least a function to call!"))
  `(,@(apply append
             (map (lambda (e)
                    (compile e environment 'call))
                  expr))
    (,call-style ,(length expr))))

(defn compile-variable-read (expr environment)
  (send environment 'generate-read expr))

(defn compile-literal (expr environment)
  `((load-value ,expr)))

(defn vars-from-ll (lambda-list)
  (cond ((nil? lambda-list) '())
        ((smatch? '&rest lambda-list)  (vars-from-ll (rest lambda-list)))
        ((cons? lambda-list)           (append (vars-from-ll (first lambda-list))
                                               (vars-from-ll (rest lambda-list))))
        ((symbol? lambda-list)         (list lambda-list))))

(defn compile-lambda ((lambda_ lambda-list &rest body-exprs) environment)
  (with-gensyms (lambda-entry after-lambda)
    `((make-lambda ,lambda-entry ,lambda-list)
      (jump ,after-lambda)
      (label ,lambda-entry)
      ,@(compile-lambda-body body-exprs
                             (send environment 'linked-with-vars
                                   (vars-from-ll lambda-list)))
      (label ,after-lambda))))

(defn compile-lambda-body (exprs environment)
  `(,@(compile-sequence exprs environment 'tail-call)
    (return)))

(defn compile-def ((def_ symbol value-expr) environment)
  `(,@(compile value-expr environment 'call)
    ,@(send global-env 'generate-write symbol)))

;; Transforming
(defn transform-let->lambda ((let_ let-clauses &rest body-exprs))
  (let ((let-variables (map first let-clauses))
        (let-expressions (map second let-clauses)))
    `((lambda ,let-variables ,@body-exprs)
      ,@let-expressions)))

(defn compile-let (expr environment call-style)
  (compile (transform-let->lambda expr) environment call-style))

(defn compile-set! ((set!_ symbol value-expr) environment)
  `(,@(compile value-expr environment 'call)
    ,@(send environment 'generate-write symbol)))

(defn compile (expr environment call-style)
  (cond
    ((number? expr)  (compile-literal expr environment))
    ((char? expr)    (compile-literal expr environment))
    ((symbol? expr)  (compile-variable-read expr environment))
    ((string? expr)  (compile-literal expr environment))
    (true
     (case (first expr)
       ((quote)      (compile-literal (second expr) environment))
       ((if)         (compile-if expr environment call-style))
       ((lambda)     (compile-lambda expr environment))
       ((let)        (compile-let expr environment call-style))
       ((def)        (compile-def expr environment))
       ((set!)       (compile-set! expr environment))
       (else         (with-asserts ((list? expr))
                       (compile-application expr environment call-style)))))))

(defn compile-sequence (exprs environment call-style)
  ;; Only the last expression keeps the tail call property.
  `(,@(apply append (map (lambda (e) `(,@(compile e environment 'call)
                                       (pop)))
                         (all-but-last exprs)))
    ,@(compile (last exprs) environment call-style)
    (pop)))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Assembler                                                     ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Byte streams
;; TODO: Move to a more appropriate file?
(defn make-byte-stream ()
  (let ((buffer ($make-mem-block 256))
        (index 0)
        (buffer-size 256))
    (dispatcher self
      ('put-byte! (byte)
         ; (println "[b] " index ": " byte)
         (when (<= buffer-size index)
           (let ((new-buffer ($make-mem-block (* index 2))))
             ($memcpy new-buffer 0
                      buffer 0
                      index)
             (set! buffer new-buffer)
             (set! buffer-size (* index 2))))
         ($mem-block-byte-set! buffer index byte)
         (set! index (+ 1 index))
         byte)
      ('put-byte-at! (trg-index byte)
         ; (println "[B] " trg-index ": " byte)
         (with-asserts ((< trg-index index))
           ($mem-block-byte-set! buffer trg-index byte)))
      ('size ()
         index)
      ('slice (first last)
         (if (eq first last)
             (list)
             (cons ($mem-block-byte-get buffer first)
                   (send self 'slice (+ 1 first) last))))
      ('buffer ()
         (let ((new-buffer ($make-mem-block index)))
           ($memcpy new-buffer 0
                    buffer 0
                    index)
           new-buffer))
      ('display ()
         (println "Byte stream:")
         (apply println
                (map (lambda (x)
                       (string-append " " (int->string x 16)))
                     (send self 'slice 0 index)))))))

(defn make-assembler (byte address-of oop-ref save-label!)
  (dispatcher self
    ('halt ()                     (byte 0))
    ('jump (label)                (byte 1) (address-of label))
    ('jump-if-true (label)        (byte 2) (address-of label))
    ('load-value (oop)            (byte 3) (oop-ref oop))
    ('read-var (f-depth v-index)  (byte 4) (byte f-depth) (byte v-index))
    ('write-var (f-depth v-index) (byte 5) (byte f-depth) (byte v-index))
    ('read-global-var (oop)       (byte 6) (oop-ref oop))
    ('write-global-var (oop)      (byte 7) (oop-ref oop))
    ('push ()                     (byte 8))
    ('pop ()                      (byte 9))
    ('make-lambda (label ll)      (byte 10) (address-of label) (oop-ref ll))
    ('call (argnum)               (byte 11) (byte argnum))
    ('tail-call (argnum)          (byte 12) (byte argnum))
    ('return ()                   (byte 13))
    ('label (l)                   (save-label! l))))

(defn lower-byte (n) (mod n 256))
(defn upper-byte (n) (/ (mod n 65536) 256))

(defn assemble (program)
  (let ((byte-stream        (make-byte-stream))
        (postponed-actions  (list))
        (label-addrs        (make-dict))
        (known-oops         (list)))
    (flet ((put-byte! (b)
             (send byte-stream 'put-byte! b))
           (put-label! (l)
             (let ((pos (send byte-stream 'size)))
               (send byte-stream 'put-byte! 0)
               (send byte-stream 'put-byte! 0)
               (add-to-list! postponed-actions
                             (lambda ()
                               (let ((label-addr (dict-get label-addrs l)))
                                 (send byte-stream 'put-byte-at! pos
                                       (upper-byte label-addr))
                                 (send byte-stream 'put-byte-at! (+ pos 1)
                                       (lower-byte label-addr)))))))
           (put-oop! (o)
             (when (not (list-contains? known-oops o))
               (add-to-list! known-oops o))
             (let ((pos (send byte-stream 'size)))
               (send byte-stream 'put-byte! 0)
               (add-to-list! postponed-actions
                             (lambda ()
                               (send byte-stream 'put-byte-at! pos
                                     (list-index-of known-oops o))))))
           (save-label! (l)
             (dict-put! label-addrs l (send byte-stream 'size))))
      (let ((translate!
             (make-assembler put-byte! put-label! put-oop! save-label!)))
        (dolist (cmd program)
          (apply translate! cmd))
        (dolist (todo postponed-actions)
          (todo))
        (list 0  ; Position where to start.
              (send byte-stream 'buffer)
              (list->array known-oops))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Putting together compiled functions.                             ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn fn-name (fn) ($mem-get fn 1))
(defn fn-lambda-list (fn) ($mem-get fn 2))
(defn fn-body (fn) ($mem-get fn 3))
(defn fn-env (fn) ($mem-get fn 4))

(defn compilable? (fn)
  ;; Note: This is the *static* global env...
  ;; If we compile a function captured in a deeper environment, we
  ;; don't know what other functions have been captured in the same.
  ;; We can't convert the environment itself to a @frame.
  (and (eq @procedure (type-of fn))
       (global-env? (fn-env fn))))

(defn compile-fn (fn)
  (if (compilable? fn)
      (let ((env-in-body (send global-env 'linked-with-vars
                               (vars-from-ll (fn-lambda-list fn)))))
        (make-compiled-procedure
         (fn-name fn)
         (fn-lambda-list fn)
         (assemble (compile-lambda-body (fn-body fn) env-in-body))
         nil))
    (progn
      ;; TODO: This is a hack to make compiling by hand convenient.
      (println "This procedure is not compilable, returning it as it is.")
      fn)))

(defn compile-fn* (fn)
  (with-asserts ((compilable? fn))
    (compile-lambda-body (fn-body fn)
                         (send global-env 'linked-with-vars
                               (vars-from-ll (fn-lambda-list fn))))))

(defmacro c! (s)
  `(set! ,s (compile-fn ,s)))

(defn uncompiled-functions ()
  (map first (filter (lambda (kv) (compilable? (rest kv)))
                     (dict-key-value-pairs $global-env))))

(def meeeh (list make-assembler make-byte-stream assemble))

)
