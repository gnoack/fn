
(

(defn map-letdefinitions (fn e)
  (list 'let
	(map (lambda (x) (list (first x)
			       (fn (second x))))
	     (second e))
	(third e)))

(defn map-letbody (fn e)
  (list 'let (second e) (fn (third e))))

(defn map-letexprs (fn e)
  (map-letdefinitions fn (map-letbody fn e)))

(def let? (smatcher 'let))
(def lambda? (smatcher 'lambda))
(def if? (smatcher 'if))
(def def? (smatcher 'def))
(def quote? (smatcher 'quote))

(defn traverse-expr (e recurse)
  (cond
    ((let? e)
     (map-letexprs recurse e))
    ((lambda? e)
     (list 'lambda (second e) (recurse (third e))))
    ((if? e)
     (cons 'if (map recurse (rest e))))
    ((def? e)
     (list 'def (second e) (recurse (third e))))
    ((quote? e)
     (list 'quote (recurse (second quote))))
    ((cons? e)
     (map recurse e))
    (true e)))

(defn defines-var? (letexpr var)
  (any? (map (lambda (definition-clause)
	       (eq var (first definition-clause)))
	     (second letexpr))))

;; Replace the free variable v1 in e with v2.
(defn replace-var (e v1 v2)
  (let ((recurse (lambda (x) (replace-var x v1 v2))))
    (cond
      ((eq e v1) v2)
      ((let? e)
       (if (defines-var? e v1)
           (map-letdefinitions recurse e)
           (map-letexprs recurse e)))
      (true (traverse-expr e recurse)))))


;;;; *****************************************
;;;; Simple OO using symbol-based dispatching.
;;;; *****************************************

(defn dispatch-clause->cond-clause (clause)
  (list (list 'eq (first clause) 'selector)
	(list 'lambda (second clause) (third clause))))

;; Constructs an object with identity and able to receive messages.
(defmacro dispatcher (name &rest defs)
  ;; `(labels ((,name (lambda (selector &rest args)
  ;;                    (apply (cond ,(map dispatch-clause->cond-clause defs))
  ;;                           args))))
  ;;    ,name)
  (list 'labels
	(list (list name
		    (list 'lambda (list 'selector '&rest 'args)
			  (list 'apply
				(cons 'cond (map dispatch-clause->cond-clause defs))
				'args))))
	name))

;; Like apply, but for sending messages.
(defn send (receiver message arguments)
  (apply receiver (cons message arguments)))



;; Static variable environment
(def empty-env
  (dispatcher self
   ('prettyprint ()           "[]")
   ('with-vars (&rest vars)   (env-with-vars self vars))
   ('immediate-size ()        0)
   ('immediate-position (var) (error var " undefined in env"))
   ('defines-immediately? (x) false)
   ('generate-read (x)        (env-generate-read self x))
   ('generate-write (x)       (env-generate-write self x))))

(defn env-with-var (env var)
  (dispatcher self
   ('prettyprint ()
       (append (symbol->string var) "::" (env 'prettyprint)))
   ('defines-immediately? (x)
       (or (eq var x)
           (env 'defines-immediately? x)))
   ;; Size and position
   ('immediate-position (x)
       (if (eq var x)
	   0
	   (+ 1 (env 'immediate-position x))))
   ('immediate-size ()       (+ 1 (env 'immediate-size)))
   ;; Construction
   ('with-vars (&rest vars)  (env-with-vars self vars))
   ;; Code generation
   ('generate-read (x)       (env-generate-read self x))
   ('generate-write (x)      (env-generate-write self x))))

(defn env-with-vars (env vars)
  (reduce env-with-var vars env))

(defn env-generate-read (env var)
  (if (env 'defines-immediately? var)
      (list 'load-var (- (env 'immediate-size)
                         (env 'immediate-position var)))
      (error var " not defined immediately")))

(defn env-generate-write (env var)
  (if (env 'defines-immediately? var)
      (list 'save-var (- (env 'immediate-size)
			 (env 'immediate-position var)))
      (error var " not defined immediately")))

;; Increased for each call to gensym.
(def global-label-counter 100)
(defn gensym (prefix)
  (progn
    (def global-label-counter (+ 1 global-label-counter))
    (string->symbol (append prefix
			    "-"
			    (int->string global-label-counter 10)))))

(defn compile (expr environment)
  (cond
    ((symbol? expr)
     (append (env-generate-read environment expr)
	     (list 'push)))
    ((if? expr)
     (let ((true-branch-label (gensym "true-branch"))
	   (after-if-label (gensym "after-if")))
       (append (compile (second expr) environment)  ; Condition
	       (list 'pop
		     'jump-if-true true-branch-label)
	       (compile (fourth expr) environment)  ; False-branch
	       (list 'jump after-if-label
		     'label true-branch-label)
	       (compile (third expr) environment)   ; True-branch
	       (list 'label after-if-label))))
    ((let? expr)
     (let ((environment2
	    (send environment 'with-vars (map first (second expr)))))
       (append (apply append
		      (map (lambda (let-clause)
			     (append (compile (second let-clause) environment)
				     (list 'pop)
				     (env-generate-write environment2
							 (first let-clause))))
			   (second expr)))
	       (compile (third expr) environment2))))
    ((list? expr)
     (append (apply append
    		    (map (lambda (e)
    			   (compile e environment))
    			 (reverse expr)))
    	     (list 'pop
    		   'call (- (length expr) 1))))
    ((number? expr)
      (list 'load-value expr
	    'push))))


)
