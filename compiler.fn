
(

(defn map-letdefinitions (fn e)
  (list 'let
	(map (lambda (x) (list (first x)
			       (fn (second x))))
	     (second e))
	(third e)))

(defn map-letbody (fn e)
  (list 'let (second e) (fn (third e))))

(defn map-letexprs (fn e)
  (map-letdefinitions fn (map-letbody fn e)))

(def let? (smatcher 'let))
(def lambda? (smatcher 'lambda))
(def if? (smatcher 'if))
(def def? (smatcher 'def))
(def quote? (smatcher 'quote))

(defn traverse-expr (e recurse)
  (cond
    ((let? e)
     (map-letexprs recurse e))
    ((lambda? e)
     (list 'lambda (second e) (recurse (third e))))
    ((if? e)
     (cons 'if (map recurse (rest e))))
    ((def? e)
     (list 'def (second e) (recurse (third e))))
    ((quote? e)
     (list 'quote (recurse (second quote))))
    ((cons? e)
     (map recurse e))
    (true e)))

(defn defines-var? (letexpr var)
  (any? (map (lambda (definition-clause)
	       (eq var (first definition-clause)))
	     (second letexpr))))

;; Replace the free variable v1 in e with v2.
(defn replace-var (e v1 v2)
  (let ((recurse (lambda (x) (replace-var x v1 v2))))
    (cond
      ((eq e v1) v2)
      ((let? e)
       (if (defines-var? e v1)
           (map-letdefinitions recurse e)
           (map-letexprs recurse e)))
      (true (traverse-expr e recurse)))))

(defn dispatch-clause->cond-clause (clause)
  (list (list 'eq (first clause) 'selector)
	(list 'lambda (second clause) (third clause))))

;; Constructs an object with identity and able to receive messages.
(defmacro dispatcher (name &rest defs)
  ;; `(labels ((,name (lambda (selector &rest args)
  ;;                    (apply (cond ,(map dispatch-clause->cond-clause defs))
  ;;                           args))))
  ;;    ,name)
  (list 'labels
	(list (list name
		    (list 'lambda (list 'selector '&rest 'args)
			  (list 'apply
				(cons 'cond (map dispatch-clause->cond-clause defs))
				'args))))
	name))

;; Static variable environment
(def empty-env
  (dispatcher
   self
   ('prettyprint () "[]")
   ('immediate-size () 0)
   ('immediate-position (var) (error var " undefined in env"))
   ('defines-immediately? (x) false)))

(defn env-with-var (env var)
  (dispatcher
   self
   ('prettyprint ()
       (append (symbol->string var) "::" (env 'prettyprint)))
   ('immediate-size () (+ 1 (env 'immediate-size)))
   ('immediate-position (x)
       (if (eq var x)
	   0
	   (+ 1 (env 'immediate-position x))))
   ('defines-immediately? (x)
       (or (eq var x)
           (env 'defines-immediately? x)))))

(defn env-with-vars (env &rest vars)
  (reduce env-with-var vars env))

(defn env-generate-read (env var)
  (if (env 'defines-immediately? var)
      (list 'load-var (- (env 'immediate-size)
                         (env 'immediate-position var)))
      (error var " not defined immediately")))

(defn env-generate-write (env var)
  (if (env 'defines-immediately? var)
      (list 'save-var (- (env 'immediate-size)
			 (env 'immediate-position var)))
      (error var " not defined immediately")))

;; Increased for each call to gensym.
(def global-label-counter 100)
(defn gensym (prefix)
  (progn
    (def global-label-counter (+ 1 global-label-counter))
    (string->symbol (append prefix
			    "-"
			    (int->string global-label-counter 10)))))

(defn compile (expr environment)
  (cond
    ((symbol? expr)
     (append (env-generate-read environment expr)
	     (list 'push)))
    ((if? expr)
     (let ((true-branch-label (gensym "true-branch"))
	   (after-if-label (gensym "after-if")))
       (append (compile (second expr) environment)  ; Condition
	       (list 'pop
		     'jump-if-true true-branch-label)
	       (compile (fourth expr) environment)  ; False-branch
	       (list 'jump after-if-label
		     'label true-branch-label)
	       (compile (third expr) environment)   ; True-branch
	       (list 'label after-if-label))))
    ((let? expr)
     (let ((environment2
	    (apply env-with-vars
		   (cons environment (map first (second expr))))))
       (append (apply append
		      (map (lambda (let-clause)
			     (append (compile (second let-clause) environment)
				     (list 'pop)
				     (env-generate-write environment2
							 (first let-clause))))
			   (second expr)))
	       (compile (third expr) environment2))))
    ((list? expr)
     (append (apply append
    		    (map (lambda (e)
    			   (compile e environment))
    			 (reverse expr)))
    	     (list 'pop
    		   'call (- (length expr) 1))))
    ((number? expr)
      (list 'load-value expr
	    'push))))


)
