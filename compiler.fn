
(

;;; TODO: Delete the whole traversal code, it is probably not needed.
(defn map-letdefinitions (fn e)
  (list 'let
        (map (lambda (x) (list (first x)
                               (fn (second x))))
             (second e))
        (third e)))

(defn map-letbody (fn e)
  (list 'let (second e) (fn (third e))))

(defn map-letexprs (fn e)
  (map-letdefinitions fn (map-letbody fn e)))

(def let? (smatcher 'let))
(def lambda? (smatcher 'lambda))
(def if? (smatcher 'if))
(def def? (smatcher 'def))
(def quote? (smatcher 'quote))

(defn traverse-expr (e recurse)
  (cond
    ((let? e)     (map-letexprs recurse e))
    ((lambda? e)  (list 'lambda (second e) (recurse (third e))))
    ((if? e)      (cons 'if (map recurse (rest e))))
    ((def? e)     (list 'def (second e) (recurse (third e))))
    ((quote? e)   (list 'quote (recurse (second quote))))
    ((cons? e)    (map recurse e))
    (true         e)))

(defn defines-var? (letexpr var)
  (any? (map (lambda (definition-clause)
               (eq var (first definition-clause)))
             (second letexpr))))

;; Replace the free variable v1 in e with v2.
(defn replace-var (e v1 v2)
  (let ((recurse (lambda (x) (replace-var x v1 v2))))
    (cond
      ((eq e v1) v2)
      ((let? e)
       (if (defines-var? e v1)
           (map-letdefinitions recurse e)
           (map-letexprs recurse e)))
      (true (traverse-expr e recurse)))))



;; Accessing elements in lists.
(defm @cons 'contains? (v)
  (or (eq v (first self))
      (send (rest self) 'contains? v)))

(defm @nil 'contains? (v)
  false)

(defm @cons 'index-of (v)
  (if (eq v (first self))
      0
      (+ 1 (send (rest self) 'index-of v))))

(def contains? (sender 'contains?))
(def index-of (sender 'index-of))


;;; Static variable environment

(defn %globalop (op)
  (cond ((eq op 'write-var) 'write-global-var)
        ((eq op 'read-var)  'read-global-var)
        (true               (error "Unknown variable access mode: " op))))

(def global-env
  (dispatcher self
   ('prettyprint ()                "GLOBAL")

   ;; Construction
   ('linked-with-vars (vars)       (linked-env-with-vars self vars))

   ;; Code generation
   ('generate-access (depth op x)  (list (%globalop op) x))
   ('generate-read (x)             (send self 'generate-access 0 'read-var x))
   ('generate-write (x)            (send self 'generate-access 0 'write-var x))
))

(defn linked-env-with-vars (next-env my-vars)
  (dispatcher self
   ('prettyprint ()                (append (pprint my-vars) "::"
                                           (send next-env 'prettyprint)))

   ;; Construction
   ('linked-with-vars (vars)       (linked-env-with-vars self vars))

   ;; Code generation
   ('generate-access (depth op x)  (if (contains? my-vars x)
                                       (list op depth (index-of my-vars x))
                                       (send next-env 'generate-access (+ 1 depth) op x)))
   ('generate-read (x)             (send self 'generate-access 0 'read-var x))
   ('generate-write (x)            (send self 'generate-access 0 'write-var x))
))


;; Gensym for generating unused symbols.
(def global-label-counter 100)
(defn gensym (prefix)
  (progn
    (def global-label-counter (+ 1 global-label-counter))
    (string->symbol (append prefix
                            "-"
                            (int->string global-label-counter 10)))))

;;; Compilation

(defn compile-if (expr environment)
  (let ((true-branch-label (gensym "true-branch"))
        (after-if-label (gensym "after-if")))
    (append (compile (second expr) environment)  ; Condition
            (list 'pop
                  'jump-if-true true-branch-label)
            (compile (fourth expr) environment)  ; False-branch
            (list 'jump after-if-label
                  'label true-branch-label)
            (compile (third expr) environment)   ; True-branch
            (list 'label after-if-label))))

(defn compile-application (expr environment)
  (append (apply append
                 (map (lambda (e)
                        (compile e environment))
                      (reverse expr)))
          (list 'pop
                'call (- (length expr) 1))))

(defn compile-variable-read (expr environment)
  (append (send environment 'generate-read expr)
          (list 'push)))

(defn compile-number-literal (expr environment)
  (list 'load-value expr
        'push))

;; TODO: Implement let by transforming it to a lambda.
;; TODO: Implement lambda by chaining environments.
(defn compile (expr environment)
  (cond
    ((symbol? expr)  (compile-variable-read expr environment))
    ((if? expr)      (compile-if expr environment))
    ((list? expr)    (compile-application expr environment))
    ((number? expr)  (compile-number-literal expr environment))))

)
