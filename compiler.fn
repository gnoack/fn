
(

(defn map-letdefinitions (fn e)
  (list 'let
	(map (lambda (x) (list (first x)
			       (fn (second x))))
	     (second e))
	(third e)))

(defn map-letbody (fn e)
  (list 'let (second e) (fn (third e))))

(defn map-letexprs (fn e)
  (map-letdefinitions fn (map-letbody fn e)))

(def let? (smatcher 'let))
(def lambda? (smatcher 'lambda))
(def if? (smatcher 'if))
(def def? (smatcher 'def))
(def quote? (smatcher 'quote))

(defn traverse-expr (e recurse)
  (cond
    ((let? e)
     (map-letexprs recurse e))
    ((lambda? e)
     (list 'lambda (second e) (recurse (third e))))
    ((if? e)
     (cons 'if (map recurse (rest e))))
    ((def? e)
     (list 'def (second e) (recurse (third e))))
    ((quote? e)
     (list 'quote (recurse (second quote))))
    ((cons? e)
     (map recurse e))
    (true e)))

(defn defines-var? (letexpr var)
  (any? (map (lambda (definition-clause)
	       (eq var (first definition-clause)))
	     (second letexpr))))

;; Replace the free variable v1 in e with v2.
(defn replace-var (e v1 v2)
  (let ((recurse (lambda (x) (replace-var x v1 v2))))
    (cond
      ((eq e v1) v2)
      ((let? e)
       (if (defines-var? e v1)
           (map-letdefinitions recurse e)
           (map-letexprs recurse e)))
      (true (traverse-expr e recurse)))))

(defn dispatch-clause->cond-clause (clause)
  (list (list 'eq (first clause) 'selector)
	(list 'lambda (second clause) (third clause))))

(defmacro dispatcher (&rest defs)
  (list 'lambda (list 'selector '&rest 'args)
	(list 'apply
	      (cons 'cond (map dispatch-clause->cond-clause defs))
	      'args)))

;; Static variable environment
(def empty-env
  (dispatcher
   ('prettyprint () "[]")
   ('immediate-size () 0)
   ('immediate-position (var) (error var " undefined in env"))
   ('defines-immediately? (x) false)))

(defn env-with-var (env var)
  (dispatcher
   ('prettyprint ()
       (append (symbol->string var) "::" (env 'prettyprint)))
   ('immediate-size () (+ 1 (env 'immediate-size)))
   ('immediate-position (x)
       (if (eq var x)
	   0
	   (+ 1 (env 'immediate-position x))))
   ('defines-immediately? (x)
       (or (eq var x)
           (env 'defines-immediately? x)))))

(defn env-with-vars (env &rest vars)
  (reduce env-with-var vars env))

(defn env-generate-read (env var)
  (if (env 'defines-immediately? var)
      (list 'load-arg (- (env 'immediate-size)
                         (env 'immediate-position var)))
      (error var "not defined immediately")))

)
