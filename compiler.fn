
(


;; Byte streams
;; TODO: Move to a more appropriate file and test this.
(defn make-byte-stream ()
  ;; TODO: Handle overflow.
  (let ((memory ($make-mem-block 100))
        (index 0))
    (dispatcher self
      ('put-byte! (byte)
         ($mem-block-byte-set! memory index byte)
         (set! index (+ 1 index))
         byte)
      ('size ()
         index)
      ('slice (first last)
         (if (eq first last)
             (list)
             (cons ($mem-block-byte-get memory first)
                   (send self 'slice (+ 1 first) last))))
      ('display ()
         (writeout "byte stream: ")
         (apply awriteout
                (map (lambda (x)
                       (string-append " " (int->string x 16)))
                     (send self 'slice 0 index)))))))


;; Recognizing s-expressions.
(defn let? (e) (smatch? 'let e))
(defn lambda? (e) (smatch? 'lambda e))
(defn if? (e) (smatch? 'if e))
(defn def? (e) (smatch? 'def e))
(defn quote? (e) (smatch? 'quote e))
(defn set!? (e) (smatch? 'set! e))


;; Accessing elements in lists.
(defm @cons 'contains? (v)
  (or (eq v (first self))
      (send (rest self) 'contains? v)))

(defm @nil 'contains? (v)
  false)

(defm @cons 'index-of (v)
  (if (eq v (first self))
      0
      (+ 1 (send (rest self) 'index-of v))))

(def contains? (sender 'contains?))
(def index-of (sender 'index-of))


;;; Static variable environment

(defn %globalop (op)
  (case op
    ((write-var) 'write-global-var)
    ((read-var)  'read-global-var)
    (else        (error "Unknown variable access mode: " op))))

(def global-env
  (dispatcher self
   ('prettyprint ()                "GLOBAL")

   ;; Construction
   ('linked-with-vars (vars)       (linked-env-with-vars self vars))

   ;; Code generation
   ('generate-access (depth op x)  `((,(%globalop op) ,x)))
   ('generate-read (x)             (send self 'generate-access 0 'read-var x))
   ('generate-write (x)            (send self 'generate-access 0 'write-var x))
))

(defn linked-env-with-vars (next-env my-vars)
  (dispatcher self
   ('prettyprint ()                (string-append (pprint my-vars) "::"
                                                  (send next-env 'prettyprint)))

   ;; Construction
   ('linked-with-vars (vars)       (linked-env-with-vars self vars))

   ;; Code generation
   ('generate-access (depth op x)  (if (contains? my-vars x)
                                       `((,op ,depth ,(index-of my-vars x)))
                                       (send next-env 'generate-access (+ 1 depth) op x)))
   ('generate-read (x)             (send self 'generate-access 0 'read-var x))
   ('generate-write (x)            (send self 'generate-access 0 'write-var x))
))


;; Gensym for generating unused symbols.
(def global-label-counter 100)
(defn gensym (prefix)
  (set! global-label-counter (+ 1 global-label-counter))
  (string->symbol (string-append prefix
                                 "-"
                                 (int->string global-label-counter 10))))

;;; Compilation

(defn compile-if (expr environment)
  (let ((true-branch-label (gensym "true-branch"))
        (after-if-label (gensym "after-if")))
    `(,@(compile (second expr) environment)  ; Condition.
      (pop)
      (jump-if-true ,true-branch-label)
      ,@(compile (fourth expr) environment)  ; False branch.
      (jump ,after-if-label)
      (label ,true-branch-label)
      ,@(compile (third expr) environment)  ; True branch.
      (label ,after-if-label))))

(defn compile-application (expr environment)
  `(,@(apply append
             (map (lambda (e)
                    (compile e environment))
                  (reverse expr)))
    (pop)
    (call ,(- (length expr) 1))))

(defn compile-variable-read (expr environment)
  `(,@(send environment 'generate-read expr)
    (push)))

(defn compile-literal (expr environment)
  `((load-value ,expr)
    (push)))

;; TODO: Support for variable length argument lists.
(def lambda-list second)
(def lambda-body third)
(defn compile-lambda (expr environment)
  (let ((lambda-entry-label (gensym "lambda-entry"))
        (after-lambda-label (gensym "after-lambda")))
    `((make-lambda ,lambda-entry-label)
      (push)
      (jump ,after-lambda-label)
      (label ,lambda-entry-label)
      ,@(compile (lambda-body expr)
                 (send environment 'linked-with-vars (lambda-list expr)))
      (return)
      (label ,after-lambda-label))))

(defn compile-def (expr environment)
  `(,@(compile (third expr) environment)
    (pop)
    ,@(send global-env 'generate-write (second expr))))

;; Transforming
(def let-clauses second)
(def let-body third)
(defn let-variables (e) (map first (let-clauses e)))
(defn let-expressions (e) (map second (let-clauses e)))
(defn transform-let->lambda (expr)
  `((lambda ,(let-variables expr) ,(let-body expr))
    ,@(let-expressions expr)))

(defn compile-let (expr environment)
  (compile (transform-let->lambda expr) environment))

(defn compile-set! (expr environment)
  `(,@(compile (third expr) environment)
    (pop)
    ,@(send environment 'generate-write (second expr))))

(defn compile (expr environment)
  (cond
    ((number? expr)  (compile-literal expr environment))
    ((char? expr)    (compile-literal expr environment))
    ((quote? expr)   (compile-literal (second expr) environment))
    ((symbol? expr)  (compile-variable-read expr environment))
    ((if? expr)      (compile-if expr environment))
    ((lambda? expr)  (compile-lambda expr environment))
    ((let? expr)     (compile-let expr environment))
    ((def? expr)     (compile-def expr environment))
    ((set!? expr)    (compile-set! expr environment))
    ((list? expr)    (compile-application expr environment))))

)
