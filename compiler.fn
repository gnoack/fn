
(

;; Recognizing s-expressions.
(defn let? (e) (smatch? 'let e))
(defn lambda? (e) (smatch? 'lambda e))
(defn if? (e) (smatch? 'if e))
(defn def? (e) (smatch? 'def e))
(defn quote? (e) (smatch? 'quote e))
(defn set!? (e) (smatch? 'set! e))


;; Accessing elements in lists.
(defm @cons 'contains? (v)
  (or (eq v (first self))
      (send (rest self) 'contains? v)))

(defm @nil 'contains? (v)
  false)

(defm @cons 'index-of (v)
  (if (eq v (first self))
      0
      (+ 1 (send (rest self) 'index-of v))))

(def contains? (sender 'contains?))
(def index-of (sender 'index-of))


;;; Static variable environment

(defn %globalop (op)
  (case op
    ((write-var) 'write-global-var)
    ((read-var)  'read-global-var)
    (else        (error "Unknown variable access mode: " op))))

(def global-env
  (dispatcher self
   ('prettyprint ()                "GLOBAL")

   ;; Construction
   ('linked-with-vars (vars)       (linked-env-with-vars self vars))

   ;; Code generation
   ('generate-access (depth op x)  `((,(%globalop op) ,x)))
   ('generate-read (x)             (send self 'generate-access 0 'read-var x))
   ('generate-write (x)            (send self 'generate-access 0 'write-var x))
))

(defn linked-env-with-vars (next-env my-vars)
  (dispatcher self
   ('prettyprint ()                (string-append (pprint my-vars) "::"
                                                  (send next-env 'prettyprint)))

   ;; Construction
   ('linked-with-vars (vars)       (linked-env-with-vars self vars))

   ;; Code generation
   ('generate-access (depth op x)  (if (contains? my-vars x)
                                       `((,op ,depth ,(index-of my-vars x)))
                                       (send next-env 'generate-access (+ 1 depth) op x)))
   ('generate-read (x)             (send self 'generate-access 0 'read-var x))
   ('generate-write (x)            (send self 'generate-access 0 'write-var x))
))


;; Gensym for generating unused symbols.
(def global-label-counter 100)
(defn gensym (prefix)
  (set! global-label-counter (+ 1 global-label-counter))
  (string->symbol (string-append prefix
                                 "-"
                                 (int->string global-label-counter 10))))

;;; Compilation

(defn compile-if (expr environment)
  (let ((true-branch-label (gensym "true-branch"))
        (after-if-label (gensym "after-if")))
    `(,@(compile (second expr) environment)  ; Condition.
      (pop)
      (jump-if-true ,true-branch-label)
      ,@(compile (fourth expr) environment)  ; False branch.
      (jump ,after-if-label)
      (label ,true-branch-label)
      ,@(compile (third expr) environment)  ; True branch.
      (label ,after-if-label))))

(defn compile-application (expr environment)
  `(,@(apply append
             (map (lambda (e)
                    (compile e environment))
                  expr))
    (call ,(length expr))
    (push)))

(defn compile-variable-read (expr environment)
  `(,@(send environment 'generate-read expr)
    (push)))

(defn compile-literal (expr environment)
  `((load-value ,expr)
    (push)))

(defn vars-from-ll (lambda-list)
  (cond ((nil? lambda-list) '())
        ((smatch? '&rest lambda-list)  (vars-from-ll (rest lambda-list)))
        ((cons? lambda-list)           (append (vars-from-ll (first lambda-list))
                                               (vars-from-ll (rest lambda-list))))
        ((symbol? lambda-list)         (list lambda-list))))

(def lambda-list second)
(defn lambda-body (e) (rest (rest e)))
(defn compile-lambda (expr environment)
  (let ((lambda-entry-label (gensym "lambda-entry"))
        (after-lambda-label (gensym "after-lambda")))
    `((make-lambda ,lambda-entry-label ,(lambda-list expr))
      (push)
      (jump ,after-lambda-label)
      (label ,lambda-entry-label)
      ,@(compile-lambda-body (lambda-body expr)
                             (send environment 'linked-with-vars
                                   (vars-from-ll (lambda-list expr))))
      (label ,after-lambda-label))))

(defn compile-lambda-body (exprs environment)
  `(,@(compile-sequence exprs environment)
    (pop)
    (return)))

(defn compile-def (expr environment)
  `(,@(compile (third expr) environment)
    (pop)
    ,@(send global-env 'generate-write (second expr))))

;; Transforming
(def let-clauses second)
(def let-body third)
(defn let-variables (e) (map first (let-clauses e)))
(defn let-expressions (e) (map second (let-clauses e)))
(defn transform-let->lambda (expr)
  `((lambda ,(let-variables expr) ,(let-body expr))
    ,@(let-expressions expr)))

(defn compile-let (expr environment)
  (compile (transform-let->lambda expr) environment))

(defn compile-set! (expr environment)
  `(,@(compile (third expr) environment)
    (pop)
    ,@(send environment 'generate-write (second expr))))

(defn compile (expr environment)
  (cond
    ((number? expr)  (compile-literal expr environment))
    ((char? expr)    (compile-literal expr environment))
    ((quote? expr)   (compile-literal (second expr) environment))
    ((symbol? expr)  (compile-variable-read expr environment))
    ((if? expr)      (compile-if expr environment))
    ((lambda? expr)  (compile-lambda expr environment))
    ((let? expr)     (compile-let expr environment))
    ((def? expr)     (compile-def expr environment))
    ((set!? expr)    (compile-set! expr environment))
    ((list? expr)    (compile-application expr environment))))

(defn compile-sequence (exprs environment)
  (apply append (map (lambda (e) (compile e environment))
                     exprs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Assembler                                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Byte streams
;; TODO: Move to a more appropriate file and test this.
(defn make-byte-stream ()
  (let ((buffer ($make-mem-block 100))
        (index 0)
        (buffer-size 100))
    (dispatcher self
      ('put-byte! (byte)
         (when (<= buffer-size index)
           (println "Resize buffer to " (* index 2))
           (let ((new-buffer ($make-mem-block (* index 2))))
             ($memcpy new-buffer 0
                      buffer 0
                      index)
             (set! buffer new-buffer)
             (set! buffer-size (* index 2))))
         ; (println "[asm] " index ": " byte)
         ($mem-block-byte-set! buffer index byte)
         (set! index (+ 1 index))
         byte)
      ('put-byte-at! (trg-index byte)
         (with-asserts ((< trg-index index))
           ($mem-block-byte-set! buffer trg-index byte)))
      ('size ()
         index)
      ('slice (first last)
         (if (eq first last)
             (list)
             (cons ($mem-block-byte-get buffer first)
                   (send self 'slice (+ 1 first) last))))
      ;; TODO: Only return relevant part!
      ('buffer ()
         (let ((new-buffer ($make-mem-block index)))
           ($memcpy new-buffer 0
                    buffer 0
                    index)
           new-buffer))
      ('display ()
         (println "Byte stream:")
         (apply println
                (map (lambda (x)
                       (string-append " " (int->string x 16)))
                     (send self 'slice 0 index)))))))

(defn make-assembler (byte address-of oop-ref save-label!)
  (dispatcher self
    ('halt ()                     (byte 0))
    ('jump (label)                (byte 1) (address-of label))
    ('jump-if-true (label)        (byte 2) (address-of label))
    ('load-value (oop)            (byte 3) (oop-ref oop))
    ('read-var (f-depth v-index)  (byte 4) (byte f-depth) (byte v-index))
    ('write-var (f-depth v-index) (byte 5) (byte f-depth) (byte v-index))
    ('read-global-var (oop)       (byte 6) (oop-ref oop))
    ('write-global-var (oop)      (byte 7) (oop-ref oop))
    ('push ()                     (byte 8))
    ('pop ()                      (byte 9))
    ('make-lambda (label ll)      (byte 10) (address-of label) (oop-ref ll))
    ('call (argnum)               (byte 11) (byte argnum))
    ('return ()                   (byte 12))

    ('label (l)                   (save-label! l))))

(defn assemble (program)
  (let ((byte-stream        (make-byte-stream))
        (postponed-actions  (list))
        (label-addrs        empty-map)
        (known-oops         (list)))
    (flet ((put-byte! (b)
             (send byte-stream 'put-byte! b))
           (put-label! (l)
             (let ((pos (send byte-stream 'size)))
               (send byte-stream 'put-byte! 0)
               (add-to-list! postponed-actions
                             (lambda ()
                               (send byte-stream 'put-byte-at! pos
                                     (send label-addrs 'get l))))))
           (put-oop! (o)
             (when (not (contains? known-oops o))
               (add-to-list! known-oops o))
             (let ((pos (send byte-stream 'size)))
               (send byte-stream 'put-byte! 0)
               (add-to-list! postponed-actions
                             (lambda ()
                               (send byte-stream 'put-byte-at! pos
                                     (index-of known-oops o))))))
           (save-label! (l)
             (set! label-addrs
                   (send label-addrs 'put l
                         (send byte-stream 'size)))))
      (let ((translate!
             (make-assembler put-byte! put-label! put-oop! save-label!)))
        (for-each (cmd program)
          (apply translate! cmd))
        (for-each (todo postponed-actions)
          (todo))
        (list 0  ; Position where to start.
              (send byte-stream 'buffer)
              (list->array known-oops))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Putting together compiled functions.                             ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


(defn make-compiled-procedure (name lambda-list code in-frame)
  ($make @compiled-procedure name lambda-list code in-frame))

(defn fn-name (fn) ($mem-get fn 1))
(defn fn-lambda-list (fn) ($mem-get fn 2))
(defn fn-body (fn) ($mem-get fn 3))
(defn fn-env (fn) ($mem-get fn 4))

(defn compile-fn (fn)
  (with-asserts ((eq @procedure (type-of fn))
                 (global-env? (fn-env fn)))
    ;; Note: This is the static global env...
    (make-compiled-procedure
     (fn-name fn)
     (fn-lambda-list fn)
     (assemble (compile-lambda-body (fn-body fn)
                                    (send global-env 'linked-with-vars
                                          (vars-from-ll (fn-lambda-list fn)))))
     nil)))

(defn compile-fn* (fn)
  (with-asserts ((eq @procedure (type-of fn))
                 (global-env? (fn-env fn)))
    (compile-lambda-body (fn-body fn)
                         (send global-env 'linked-with-vars
                               (vars-from-ll (fn-lambda-list fn))))))

)
