
(

;; Recognizing s-expressions.
(defn let? (e) (smatch? 'let e))
(defn lambda? (e) (smatch? 'lambda e))
(defn if? (e) (smatch? 'if e))
(defn def? (e) (smatch? 'def e))
(defn quote? (e) (smatch? 'quote e))
(defn set!? (e) (smatch? 'set! e))


;; Accessing elements in lists.
(defn list-index-of (list value)
  (with-asserts ((cons? list))
    (if (eq value (first list))
        0
      (+ 1 (list-index-of (rest list) value)))))

(defn list-contains? (list value)
  (if (cons? list)
      (or (eq value (first list))
          (list-contains? (rest list) value))
      false))


;;; Static variable environment

(defn %globalop (op)
  (case op
    ((write-var) 'write-global-var)
    ((read-var)  'read-global-var)
    (else        (error "Unknown variable access mode: " op))))

(def global-env
  (dispatcher self
    ('prettyprint ()                "GLOBAL")

    ;; Construction
    ('linked-with-vars (vars)       (linked-env-with-vars self vars))

    ;; Code generation
    ('generate-access (depth op x)  `((,(%globalop op) ,x)))
    ('generate-read (x)             (send self 'generate-access 0 'read-var x))
    ('generate-write (x)            (send self 'generate-access 0 'write-var x))))

(defn linked-env-with-vars (next-env my-vars)
  (dispatcher self
    ('prettyprint ()                (string-append (pprint my-vars) "::"
                                                   (send next-env 'prettyprint)))

    ;; Construction
    ('linked-with-vars (vars)       (linked-env-with-vars self vars))

    ;; Code generation
    ('generate-access (depth op x)  (if (list-contains? my-vars x)
                                        `((,op ,depth ,(list-index-of my-vars x)))
                                      (send next-env 'generate-access (+ 1 depth) op x)))
    ('generate-read (x)             (send self 'generate-access 0 'read-var x))
    ('generate-write (x)            (send self 'generate-access 0 'write-var x))))


;; Gensym for generating unused symbols.
(def global-label-counter 100)
(defn gensym (prefix)
  (set! global-label-counter (+ 1 global-label-counter))
  (string->symbol (string-append prefix
                                 "-"
                                 (int->string global-label-counter 10))))

;;; Compilation

(defn compile-if ((if_ condition-expr consequent-expr alternative-expr)
                  environment)
  (let ((true-branch-label (gensym "true-branch"))
        (after-if-label (gensym "after-if")))
    `(,@(compile condition-expr environment)
      (pop)
      (jump-if-true ,true-branch-label)
      ,@(compile alternative-expr environment)
      (jump ,after-if-label)
      (label ,true-branch-label)
      ,@(compile consequent-expr environment)
      (label ,after-if-label))))

(defn compile-application (expr environment)
  (when (nil? expr)
    (error "Need at least a function to call!"))
  `(,@(apply append
             (map (lambda (e)
                    (compile e environment))
                  expr))
    (call ,(length expr))
    (push)))

(defn compile-variable-read (expr environment)
  `(,@(send environment 'generate-read expr)
    (push)))

(defn compile-literal (expr environment)
  `((load-value ,expr)
    (push)))

(defn vars-from-ll (lambda-list)
  (cond ((nil? lambda-list) '())
        ((smatch? '&rest lambda-list)  (vars-from-ll (rest lambda-list)))
        ((cons? lambda-list)           (append (vars-from-ll (first lambda-list))
                                               (vars-from-ll (rest lambda-list))))
        ((symbol? lambda-list)         (list lambda-list))))

(defn compile-lambda ((lambda_ lambda-list &rest body-exprs) environment)
  (let ((lambda-entry-label (gensym "lambda-entry"))
        (after-lambda-label (gensym "after-lambda")))
    `((make-lambda ,lambda-entry-label ,lambda-list)
      (push)
      (jump ,after-lambda-label)
      (label ,lambda-entry-label)
      ,@(compile-lambda-body body-exprs
                             (send environment 'linked-with-vars
                                   (vars-from-ll lambda-list)))
      (label ,after-lambda-label))))

(defn compile-lambda-body (exprs environment)
  `(,@(compile-sequence exprs environment)
    (return)))

(defn compile-def ((def_ symbol value-expr) environment)
  `(,@(compile value-expr environment)
    (pop)
    ,@(send global-env 'generate-write symbol)))

;; Transforming
(defn transform-let->lambda ((let_ let-clauses &rest body-exprs))
  (let ((let-variables (map first let-clauses))
        (let-expressions (map second let-clauses)))
    `((lambda ,let-variables ,@body-exprs)
      ,@let-expressions)))

(defn compile-let (expr environment)
  (compile (transform-let->lambda expr) environment))

(defn compile-set! ((set!_ symbol value-expr) environment)
  `(,@(compile value-expr environment)
    (pop)
    ,@(send environment 'generate-write symbol)
    (push)))

(defn compile (expr environment)
  (cond
    ((number? expr)  (compile-literal expr environment))
    ((char? expr)    (compile-literal expr environment))
    ((symbol? expr)  (compile-variable-read expr environment))
    ((string? expr)  (compile-literal expr environment))
    ((quote? expr)   (compile-literal (second expr) environment))
    ((if? expr)      (compile-if expr environment))
    ((lambda? expr)  (compile-lambda expr environment))
    ((let? expr)     (compile-let expr environment))
    ((def? expr)     (compile-def expr environment))
    ((set!? expr)    (compile-set! expr environment))
    ((list? expr)    (compile-application expr environment))))

(defn compile-sequence (exprs environment)
  (apply append (map (lambda (e) `(,@(compile e environment)
                                   (pop)))
                     exprs)))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Optimizer                                                     ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn longer-eq-than (n list)
  (cond ((= n 0)     true)
        ((nil? list) false)
        (true        (longer-eq-than (- n 1) (rest list)))))

(defn optimize (commands)
  (cond ((and (longer-eq-than 2 commands)
              (eql '(push) (first commands))
              (eql '(pop) (second commands)))
         (rest (rest commands)))
        (true
         (cons (first commands) (optimize (rest commands))))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Assembler                                                     ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Byte streams
;; TODO: Move to a more appropriate file?
(defn make-byte-stream ()
  (let ((buffer ($make-mem-block 256))
        (index 0)
        (buffer-size 256))
    (dispatcher self
      ('put-byte! (byte)
         ; (println "[b] " index ": " byte)
         (when (<= buffer-size index)
           (let ((new-buffer ($make-mem-block (* index 2))))
             ($memcpy new-buffer 0
                      buffer 0
                      index)
             (set! buffer new-buffer)
             (set! buffer-size (* index 2))))
         ($mem-block-byte-set! buffer index byte)
         (set! index (+ 1 index))
         byte)
      ('put-byte-at! (trg-index byte)
         ; (println "[B] " trg-index ": " byte)
         (with-asserts ((< trg-index index))
           ($mem-block-byte-set! buffer trg-index byte)))
      ('size ()
         index)
      ('slice (first last)
         (if (eq first last)
             (list)
             (cons ($mem-block-byte-get buffer first)
                   (send self 'slice (+ 1 first) last))))
      ('buffer ()
         (let ((new-buffer ($make-mem-block index)))
           ($memcpy new-buffer 0
                    buffer 0
                    index)
           new-buffer))
      ('display ()
         (println "Byte stream:")
         (apply println
                (map (lambda (x)
                       (string-append " " (int->string x 16)))
                     (send self 'slice 0 index)))))))

(defn make-assembler (byte address-of oop-ref save-label!)
  (dispatcher self
    ('halt ()                     (byte 0))
    ('jump (label)                (byte 1) (address-of label))
    ('jump-if-true (label)        (byte 2) (address-of label))
    ('load-value (oop)            (byte 3) (oop-ref oop))
    ('read-var (f-depth v-index)  (byte 4) (byte f-depth) (byte v-index))
    ('write-var (f-depth v-index) (byte 5) (byte f-depth) (byte v-index))
    ('read-global-var (oop)       (byte 6) (oop-ref oop))
    ('write-global-var (oop)      (byte 7) (oop-ref oop))
    ('push ()                     (byte 8))
    ('pop ()                      (byte 9))
    ('make-lambda (label ll)      (byte 10) (address-of label) (oop-ref ll))
    ('call (argnum)               (byte 11) (byte argnum))
    ('tail-call (argnum)          (byte 12) (byte argnum))
    ('return ()                   (byte 13))
    ('label (l)                   (save-label! l))))

(defn lower-byte (n) (mod n 256))
(defn upper-byte (n) (/ (mod n 65536) 256))

(defn assemble (program)
  (let ((byte-stream        (make-byte-stream))
        (postponed-actions  (list))
        (label-addrs        (make-dict))
        (known-oops         (list)))
    (flet ((put-byte! (b)
             (send byte-stream 'put-byte! b))
           (put-label! (l)
             (let ((pos (send byte-stream 'size)))
               (send byte-stream 'put-byte! 0)
               (send byte-stream 'put-byte! 0)
               (add-to-list! postponed-actions
                             (lambda ()
                               (let ((label-addr (dict-get label-addrs l)))
                                 (send byte-stream 'put-byte-at! pos
                                       (upper-byte label-addr))
                                 (send byte-stream 'put-byte-at! (+ pos 1)
                                       (lower-byte label-addr)))))))
           (put-oop! (o)
             (when (not (list-contains? known-oops o))
               (add-to-list! known-oops o))
             (let ((pos (send byte-stream 'size)))
               (send byte-stream 'put-byte! 0)
               (add-to-list! postponed-actions
                             (lambda ()
                               (send byte-stream 'put-byte-at! pos
                                     (list-index-of known-oops o))))))
           (save-label! (l)
             (dict-put! label-addrs l (send byte-stream 'size))))
      (let ((translate!
             (make-assembler put-byte! put-label! put-oop! save-label!)))
        (dolist (cmd program)
          (apply translate! cmd))
        (dolist (todo postponed-actions)
          (todo))
        (list 0  ; Position where to start.
              (send byte-stream 'buffer)
              (list->array known-oops))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Putting together compiled functions.                             ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn fn-name (fn) ($mem-get fn 1))
(defn fn-lambda-list (fn) ($mem-get fn 2))
(defn fn-body (fn) ($mem-get fn 3))
(defn fn-env (fn) ($mem-get fn 4))

(defn compile-fn (fn)
  (with-asserts ((eq @procedure (type-of fn))
                 (global-env? (fn-env fn)))
    ;; Note: This is the *static* global env...
    ;; If we compile a function captured in a deeper environment, we
    ;; don't know what other functions have been captured in the same.
    ;; We can't convert the environment itself to a @frame.
    (make-compiled-procedure
     (fn-name fn)
     (fn-lambda-list fn)
     (assemble
      (optimize
       (compile-lambda-body (fn-body fn)
                            (send global-env 'linked-with-vars
                                  (vars-from-ll (fn-lambda-list fn))))))
     nil)))

(defn compile-fn* (fn)
  (with-asserts ((eq @procedure (type-of fn))
                 (global-env? (fn-env fn)))
    (compile-lambda-body (fn-body fn)
                         (send global-env 'linked-with-vars
                               (vars-from-ll (fn-lambda-list fn))))))

(defmacro c! (s)
  `(set! ,s (compile-fn ,s)))

)
