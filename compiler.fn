
(

;; Recognizing s-expressions.
(def let? (smatcher 'let))
(def lambda? (smatcher 'lambda))
(def if? (smatcher 'if))
(def def? (smatcher 'def))
(def quote? (smatcher 'quote))
(def $set!? (smatcher '$set!))


;; Accessing elements in lists.
(defm @cons 'contains? (v)
  (or (eq v (first self))
      (send (rest self) 'contains? v)))

(defm @nil 'contains? (v)
  false)

(defm @cons 'index-of (v)
  (if (eq v (first self))
      0
      (+ 1 (send (rest self) 'index-of v))))

(def contains? (sender 'contains?))
(def index-of (sender 'index-of))


;;; Static variable environment

(defn %globalop (op)
  (cond ((eq op 'write-var) 'write-global-var)
        ((eq op 'read-var)  'read-global-var)
        (true               (error "Unknown variable access mode: " op))))

(def global-env
  (dispatcher self
   ('prettyprint ()                "GLOBAL")

   ;; Construction
   ('linked-with-vars (vars)       (linked-env-with-vars self vars))

   ;; Code generation
   ('generate-access (depth op x)  (list (%globalop op) x))
   ('generate-read (x)             (send self 'generate-access 0 'read-var x))
   ('generate-write (x)            (send self 'generate-access 0 'write-var x))
))

(defn linked-env-with-vars (next-env my-vars)
  (dispatcher self
   ('prettyprint ()                (append (pprint my-vars) "::"
                                           (send next-env 'prettyprint)))

   ;; Construction
   ('linked-with-vars (vars)       (linked-env-with-vars self vars))

   ;; Code generation
   ('generate-access (depth op x)  (if (contains? my-vars x)
                                       (list op depth (index-of my-vars x))
                                       (send next-env 'generate-access (+ 1 depth) op x)))
   ('generate-read (x)             (send self 'generate-access 0 'read-var x))
   ('generate-write (x)            (send self 'generate-access 0 'write-var x))
))


;; Gensym for generating unused symbols.
(def global-label-counter 100)
(defn gensym (prefix)
  (progn
    (def global-label-counter (+ 1 global-label-counter))
    (string->symbol (append prefix
                            "-"
                            (int->string global-label-counter 10)))))

;;; Compilation

(defn compile-if (expr environment)
  (let ((true-branch-label (gensym "true-branch"))
        (after-if-label (gensym "after-if")))
    (append (compile (second expr) environment)  ; Condition
            (list 'pop
                  'jump-if-true true-branch-label)
            (compile (fourth expr) environment)  ; False-branch
            (list 'jump after-if-label
                  'label true-branch-label)
            (compile (third expr) environment)   ; True-branch
            (list 'label after-if-label))))

(defn compile-application (expr environment)
  (append (apply append
                 (map (lambda (e)
                        (compile e environment))
                      (reverse expr)))
          (list 'pop
                'call (- (length expr) 1))))

(defn compile-variable-read (expr environment)
  (append (send environment 'generate-read expr)
          (list 'push)))

(defn compile-number-literal (expr environment)
  (list 'load-value expr
        'push))

;; TODO: Support for variable length argument lists.
(def lambda-list second)
(def lambda-body third)
(defn compile-lambda (expr environment)
  (let ((lambda-entry-label (gensym "lambda-entry"))
        (after-lambda-label (gensym "after-lambda")))
    (append (list 'make-lambda lambda-entry-label
                  'push
                  'jump after-lambda-label
                  'label lambda-entry-label)
            (compile (lambda-body expr)
                     (send environment 'linked-with-vars (lambda-list expr)))
            (list 'return
                  'label after-lambda-label))))

(defn compile-def (expr environment)
  (append (compile (third expr) environment)
          (list 'pop)
          (send global-env 'generate-write (second expr))))

;; Transforming
(def let-clauses second)
(def let-body third)
(defn let-variables (e) (map first (let-clauses e)))
(defn let-expressions (e) (map second (let-clauses e)))
(defn transform-let->lambda (expr)
  ;; `((lambda ,(let-variables expr) ,(let-body expr))
  ;;   ,@(let-expressions expr))
  (cons (list 'lambda
              (let-variables expr)
              (let-body expr))
        (let-expressions expr)))

(defn compile-let (expr environment)
  (compile (transform-let->lambda expr) environment))

(defn compile-$set! (expr environment)
  (let ((variable   (second expr))
        (value-expr (third expr)))
    (append (compile value-expr environment)
            (list 'pop)
            (send environment 'generate-write variable))))

(defn compile (expr environment)
  (cond
    ((symbol? expr)  (compile-variable-read expr environment))
    ((if? expr)      (compile-if expr environment))
    ((lambda? expr)  (compile-lambda expr environment))
    ((let? expr)     (compile-let expr environment))
    ((def? expr)     (compile-def expr environment))
    (($set!? expr)   (compile-$set! expr environment))
    ((list? expr)    (compile-application expr environment))
    ((number? expr)  (compile-number-literal expr environment))))

)
