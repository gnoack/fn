
(

;;; TODO: Delete the whole traversal code, it is probably not needed.
(defn map-letdefinitions (fn e)
  (list 'let
	(map (lambda (x) (list (first x)
			       (fn (second x))))
	     (second e))
	(third e)))

(defn map-letbody (fn e)
  (list 'let (second e) (fn (third e))))

(defn map-letexprs (fn e)
  (map-letdefinitions fn (map-letbody fn e)))

(def let? (smatcher 'let))
(def lambda? (smatcher 'lambda))
(def if? (smatcher 'if))
(def def? (smatcher 'def))
(def quote? (smatcher 'quote))

(defn traverse-expr (e recurse)
  (cond
    ((let? e)
     (map-letexprs recurse e))
    ((lambda? e)
     (list 'lambda (second e) (recurse (third e))))
    ((if? e)
     (cons 'if (map recurse (rest e))))
    ((def? e)
     (list 'def (second e) (recurse (third e))))
    ((quote? e)
     (list 'quote (recurse (second quote))))
    ((cons? e)
     (map recurse e))
    (true e)))

(defn defines-var? (letexpr var)
  (any? (map (lambda (definition-clause)
	       (eq var (first definition-clause)))
	     (second letexpr))))

;; Replace the free variable v1 in e with v2.
(defn replace-var (e v1 v2)
  (let ((recurse (lambda (x) (replace-var x v1 v2))))
    (cond
      ((eq e v1) v2)
      ((let? e)
       (if (defines-var? e v1)
           (map-letdefinitions recurse e)
           (map-letexprs recurse e)))
      (true (traverse-expr e recurse)))))




;; Static variable environment
(def empty-env
  (dispatcher self
   ('prettyprint ()           "[]")
   ('with-vars (&rest vars)   (env-with-vars self vars))
   ('immediate-size ()        0)
   ('immediate-position (var) (error var " undefined in env"))
   ('defines-immediately? (x) false)
   ('generate-read (x)        (env-generate-read self x))
   ('generate-write (x)       (env-generate-write self x))))

(defn env-with-var (env var)
  (dispatcher self
   ('prettyprint ()
       (append (symbol->string var) "::" (env 'prettyprint)))
   ('defines-immediately? (x)
       (or (eq var x)
           (env 'defines-immediately? x)))
   ;; Size and position
   ('immediate-position (x)
       (if (eq var x)
	   0
	   (+ 1 (env 'immediate-position x))))
   ('immediate-size ()       (+ 1 (env 'immediate-size)))
   ;; Construction
   ('with-vars (&rest vars)  (env-with-vars self vars))
   ;; Code generation
   ('generate-read (x)       (env-generate-read self x))
   ('generate-write (x)      (env-generate-write self x))))

(defn env-with-vars (env vars)
  (reduce env-with-var vars env))

(defn env-generate-read (env var)
  (if (env 'defines-immediately? var)
      (list 'load-var (- (env 'immediate-size)
                         (env 'immediate-position var)))
      (error var " not defined immediately")))

(defn env-generate-write (env var)
  (if (env 'defines-immediately? var)
      (list 'save-var (- (env 'immediate-size)
			 (env 'immediate-position var)))
      (error var " not defined immediately")))

;; Increased for each call to gensym.
(def global-label-counter 100)
(defn gensym (prefix)
  (progn
    (def global-label-counter (+ 1 global-label-counter))
    (string->symbol (append prefix
			    "-"
			    (int->string global-label-counter 10)))))

(defn compile-if (expr environment)
  (let ((true-branch-label (gensym "true-branch"))
	(after-if-label (gensym "after-if")))
    (append (compile (second expr) environment)  ; Condition
	    (list 'pop
		  'jump-if-true true-branch-label)
	    (compile (fourth expr) environment)  ; False-branch
	    (list 'jump after-if-label
		  'label true-branch-label)
	    (compile (third expr) environment)   ; True-branch
	    (list 'label after-if-label))))

(defn compile-let (expr environment)
     (let ((environment2
	    (send environment 'with-vars (map first (second expr)))))
       (append (apply append
		      (map (lambda (let-clause)
			     (append (compile (second let-clause) environment)
				     (list 'pop)
				     (env-generate-write environment2
							 (first let-clause))))
			   (second expr)))
	       (compile (third expr) environment2))))

(defn compile-application (expr environment)
  (append (apply append
		 (map (lambda (e)
			(compile e environment))
		      (reverse expr)))
	  (list 'pop
		'call (- (length expr) 1))))

(defn compile-variable-read (expr environment)
  (append (env-generate-read environment expr)
	  (list 'push)))

(defn compile-number-literal (expr environment)
  (list 'load-value expr
	'push))

(defn compile (expr environment)
  (cond
    ((symbol? expr)  (compile-variable-read expr environment))
    ((if? expr)      (compile-if expr environment))
    ((let? expr)     (compile-let expr environment))
    ((list? expr)    (compile-application expr environment))
    ((number? expr)  (compile-number-literal expr environment))))

)
