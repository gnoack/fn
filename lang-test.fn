(

;; if-true
;; (if true 5 50) --> 5
(eq 5 (if true 5 50))

;; if-false
;; (if false 5 50) --> 50
(eq 50 (if false 5 50))

;; cascaded ifs
;;     (if (if false false true) 5 50)
;; --> (if true 5 50)
;; --> 5
(eq 5 (if (if false false true)
	  5
	  50))

;; globally bound function
;; (+ 3 7) --> 10
(eq 10 (+ 3 7))

;; simple lambda expression
;; ((lambda (x) (+ x 1)) 5) --> 6
(eq 6 ((lambda (x)
	 (+ x 1))
       5))

;; Lambda expression with multiple expressions in body.
(eq 6 ((lambda (x)
         'discard
         (+ x 1))
       5))

;; simple let
(eq 3 (let ((x 3)) x))

;; let with multiple commands returns last
(eq 2 (let ((x 1))
        1
        2))

;; let with setting inside
(eq 4 (let ((x 3))
        ($set! x 4)
        x))

;; Quote
(eq 3 '3)
(eq #\a '#\a)
(eql (cons 1 (cons 2 (cons 3 nil)))
     '(1 2 3))
(eql (cons (cons 1 nil)
	   (cons 2 (cons 3 nil)))
     '((1) 2 3))

;; &rest lambda list decomposition.
(eql (list 1 2 3)
     ((lambda (&rest rest) rest) 1 2 3))

(eq 1
    ((lambda (a &rest as) a) 1 2 3))

(eql (list 2 3)
    ((lambda (a &rest as) as) 1 2 3))

;; def -- already tested in utils
;; evaluation in environments

; _and
(eq true (_and true true))
(eq false (_and true false))
(eq false (_and false true))
(eq false (_and false false))

; _or
(eq true (_or true true))
(eq true (_or true false))
(eq true (_or false true))
(eq false (_or false false))

; Map
(eql (cons 2 (cons 3 nil))
     (cons 2 (cons 3 nil)))

(eql (cons 3 (cons 4 nil))
     (map (lambda (x) (+ 1 x))
	  (cons 2 (cons 3 nil))))

; Reduce
(eq 6 (reduce + (list 1 2 3) 0))

;; Reverse
(eql '() (reverse '()))
(eql '(a b c) (reverse '(c b a)))

; Alists
(eql (list (cons 'a 1))
     (acons 'a 1 '()))

(eql (list (cons 'a 1)
	   (cons 'b 2))
     (acons 'a 1 (acons 'b 2 '())))

(eql (list (cons 'a 1)
	   (cons 'b 2)
	   (cons 'c 3))
     (pairlis '(a b c)
	      '(1 2 3)))

(eq 2 (lookup 'b (pairlis '(a b c)
			  '(1 2 3))))

(eq false (lookup 'z (pairlis '(a b c)
			      '(1 2 3))))

; TODO: Fix bug: ((lambda (f o o) (list f o o)) 1 2 3) => '(1 2 2) !!!
;; Destructure lambda lists
(eql (list (list 1 2 3)
           (list 4 5 6)
           (list 7 8 9))
     ((lambda ((f o l &rest bar) baz)
	(list (list f o l) bar baz))
      (list 1 2 3 4 5 6) (list 7 8 9)))

;; Procedure predicate.
(eq false (procedure? 123))
(eq false (procedure? (cons 1 2)))
(procedure? (lambda () 123))
(procedure? mem?)

)