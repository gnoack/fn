
(

;; TODO: Move these to a deeper level of the language.
(defn last (l)
  (if (nil? (rest l))
      (first l)
      (last (rest l))))

(defn progn (&rest args)
  (last args))

;; TODO: Make $alloc a primitive and implement $make on top?
(defn list-of-size (capacity)
  (if (eq 0 capacity)
      '()
      (cons nil (list-of-size (- capacity 1)))))

(defn $alloc (capacity)
  (apply $make (list-of-size capacity)))


;; TODO: Use an @type instead.
(def %array-marker 'array)

;; An array is a fixed-size, tagged, modifiable data object.
(defn make-array (capacity)
  (let ((result ($alloc (+ 2 capacity))))
    (progn
      ($set result 0 %array-marker)
      ($set result 1 capacity)
      result)))

(defn array-capacity (array)
  ($get array 1))

(defn array? (value)
  (and (mem? value)
       (eq %array-marker ($get value 0))))

;; TODO: Bounds checking
(defn get (array n)
  (with-asserts ((array? array))
    ($get array (+ 2 n))))

(defn set (array n value)
  (with-asserts ((array? array)
		 (< n (array-capacity array)))
    ($set array (+ 2 n) value)))

)
