
(

;; TODO: Move these to a deeper level of the language.
(defn last (l)
  (if (nil? (rest l))
      (first l)
      (last (rest l))))

(defn progn (&rest args)
  (last args))

;; TODO: Make $alloc a primitive and implement $make on top?
(defn list-of-size (capacity)
  (if (eq 0 capacity)
      '()
      (cons nil (list-of-size (- capacity 1)))))

(defn $alloc (capacity)
  (apply $make (list-of-size capacity)))


;; TODO: Use an @type instead.
(def %array-marker 'array)

;; An array is a fixed-size, tagged, modifiable data object.
(defn make-array (capacity)
  (let ((result ($alloc (+ 2 capacity))))
    (progn
      ($set result 0 %array-marker)
      ($set result 1 capacity)
      result)))

(defn array-capacity (array)
  ($get array 1))

(defn array? (value)
  (and (mem? value)
       (eq %array-marker ($get value 0))))

;; Generic getting of items from collection objects by key.
;; An array is very much the same as a map where the keys are
;; integers.
(defgeneric get (object key))

;; TODO: Bounds checking
(defmethod get ((array? array) (number? n))
  ($get array (+ 2 n)))

(defgeneric set (object key value))

(defmethod set ((array? array) (number? n) (->true value))
  (if (< n (array-capacity array))
      ($set array (+ 2 n) value)
      (error "Index " n " out of bounds for array of size "
	     (array-capacity array))))

)
