(
;; MACROS

;; Global variable *macros* stores an alist of all macros to be
;; applied to expressions before evaluation.  A macro is a lambda of
;; an expression and it's stored in the alist with the macro name as
;; key.

;; To bootstrap this:
;;  * introduce the *macros* alist using def,
;;  * introduce the defmacro macro ('defmacro . (lambda (e) ...))
;;    and define it so that it adds a macro to the *macros* alist, in
;;    doubt by overriding.  (We need an implementation of alists for
;;    that.)

(def macroexpand-defmacro
    (lambda (macroname lambda-list body)
      ;; `(def *macros* (acons ,macroname
      ;; 		     (lambda ,lambda-list ,body) *macros*))
      (list 'def '*macros*
	    (list 'acons (list 'quote macroname)
		  (list 'lambda lambda-list body) '*macros*))))

(def *macros*
    (acons 'defmacro
	   macroexpand-defmacro '()))

(def me-lambda-rec
    (lambda (xs)
      (list 'lambda
	    (first xs)  ; lambda-list
	    (macroexpand-rec (first (rest xs))))))  ; body

(def me-let-rec
    (lambda (xs)
      (list 'let
	    (map (lambda (binding)
		   (cons (first binding)
			 (macroexpand-rec (rest binding))))
		 (first xs))  ; bindings
	    (macroexpand-rec (first (rest xs))))))

(def false? (lambda (f) (eq false f)))

;; CAN'T USE ANY MACROS ITSELF!
; if, def are handled by regular function application rules
(def macroexpand-rec
    (lambda (e)
      (if (cons? e)
	  (let ((x (first e))
		(xs (rest e)))
	    (if (eq x 'quote) e  ; just leave it
	    (if (eq x 'lambda) (me-lambda-rec xs)
	    (if (eq x 'let) (me-let-rec xs)
		(let ((expand (lookup x *macros*)))
		  (if (not (false? expand))
		      (macroexpand-rec (apply expand xs))
		      (cons x (map macroexpand-rec xs))))))))
	  e)))

;; 'macroexpand' is special in that the evaluator transforms any
;; expression with it before evaluating it.  This only happens though,
;; if macroexpand is actually defined.  As long as it's not defined,
;; no transformation is done.
(def macroexpand
    (lambda (e) (macroexpand-rec e)))

(defmacro cond (&rest pairs)
  (reduce (lambda (start item)
	    (let ((condition (first item))
		  (case (first (rest item))))
	      (list 'if condition case start)))
	  (reverse pairs)
	  '(error "No match.")))

(defmacro and (p &rest ps)
  (if (nil? ps) p
      (list 'if p (cons 'and ps) false)))

(defmacro or (p &rest ps)
  (if (nil? ps) p
      (list 'if p true (cons 'or ps))))

(defmacro defn (name lambda-list body)
  ;; `(def ,name (lambda ,lambda-list ,body))
  (list 'def name
	(list 'lambda lambda-list body)))
)
