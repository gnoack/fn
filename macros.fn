(
;; MACROS

;; Global variable *macros* stores an alist of all macros to be
;; applied to expressions before evaluation.  A macro is a lambda of
;; an expression and it's stored in the alist with the macro name as
;; key.

;; To bootstrap this:
;;  * introduce the *macros* alist using def,
;;  * introduce the defmacro macro ('defmacro . (lambda (e) ...))
;;    and define it so that it adds a macro to the *macros* alist, in
;;    doubt by overriding.  (We need an implementation of alists for
;;    that.)

(def macroexpand-defmacro
    (lambda (macroname lambda-list body)
      ;; `(def *macros* (acons ,macroname
      ;; 		     (lambda ,lambda-list ,body) *macros*))
      (list 'def '*macros*
	    (list 'acons (list 'quote macroname)
		  (list 'lambda lambda-list body) '*macros*))))

(def *macros*
    (acons 'defmacro
	   macroexpand-defmacro '()))

(def me-lambda-rec
    (lambda (xs)
      (cons 'lambda
      (cons (first xs) ; lambda-list
            (map macroexpand-rec (rest xs)))))) ; body

(def me-let-rec
    (lambda (xs)
      (cons 'let
      (cons (map (lambda (binding)
                   (cons (first binding)
                         (macroexpand-rec (rest binding))))
                 (first xs)) ; bindings
            (map macroexpand-rec (rest xs))))))

(def false? (lambda (f) (eq false f)))

;; CAN'T USE ANY MACROS ITSELF!
; if, def are handled by regular function application rules
(def macroexpand-rec
    (lambda (e)
      (if (cons? e)
	  (let ((x (first e))
		(xs (rest e)))
	    (if (eq x 'quote) e  ; just leave it
	    (if (eq x 'lambda) (me-lambda-rec xs)
	    (if (eq x 'let) (me-let-rec xs)
		(let ((expand (lookup x *macros*)))
		  (if (not (false? expand))
		      (macroexpand-rec (apply expand xs))
		      (cons x (map macroexpand-rec xs))))))))
	  e)))

;; 'macroexpand' is special in that the evaluator transforms any
;; expression with it before evaluating it.  This only happens though,
;; if macroexpand is actually defined.  As long as it's not defined,
;; no transformation is done.
(def macroexpand
    (lambda (e) (macroexpand-rec e)))

(defmacro cond (&rest pairs)
  (reduce (lambda (start item)
	    (let ((condition (first item))
		  (action (first (rest item))))
	      (list 'if condition action start)))
	  (reverse pairs)
	  '(error "No match.")))

(defmacro and (p &rest ps)
  (if (nil? ps) p
      (list 'if p (cons 'and ps) false)))

(defmacro or (p &rest ps)
  (if (nil? ps) p
      (list 'if p true (cons 'or ps))))

(defmacro defn (name lambda-list &rest body)
  ;; `(def ,name (lambda ,lambda-list ,@body))
  (list 'def name
	(cons 'lambda (cons lambda-list body))))

;; TODO: Use with-gensyms for SYM_.
(defmacro case (expr &rest clauses)
  ;; `(let ((sym_ ,expr))
  ;;    (cond
  ;;      ,@(map (lambda (clause)
  ;;               (cond ((list? (first clause))
  ;;                      `((eq (quote ,(first clause)) sym_)
  ;;                        ,(second clause)))
  ;;                     ((eq 'else (first clause))
  ;;                      `(true ,(second clause)))))
  ;;             clauses)))
  (list 'let (list (list 'sym_ expr))
        (cons 'cond
              (map (lambda (clause)
                     (cond ((list? (first clause))
                            (list (list 'eq
                                        (list 'quote
                                              (first (first clause)))
                                        'sym_)
                                  (second clause)))
                           ((eq 'else (first clause))
                            (list 'true (second clause)))))
                   clauses))))

;;; ***********************************************************
;;; Backquote implementation
;;; ***********************************************************

(defn smatcher (symbol)
  (lambda (e)
    (and (cons? e)
	 (eq symbol (first e)))))

(def comma-expr? (smatcher 'unquote))
(def comma-at-expr? (smatcher 'unquote-list))

(defmacro backquote (expr)
  (if (list? expr)
      (cons 'append (map backquote-splice expr))
      (list 'quote expr)))

(defn backquote-splice (expr)
  (cond ((comma-expr? expr)    (list 'list (second expr)))
	((comma-at-expr? expr) (second expr))
	(true                  (list 'list (list 'backquote expr)))))

;;; *******************************************************************
;;; wrap for debugging
;;; *******************************************************************
;; TODO: Move this somewhere else!

;; Writeout multiple strings
(defn awriteout (&rest args)
  (writeout (apply string-append args)))

;; Wraps a method to print out its arguments.  (trace)
(defn debugging-wrap (func-symbol func)
  (lambda (&rest args)
    (awriteout "Called " (pprint (cons func-symbol args)))
    (let ((result (apply func args)))
      (awriteout "  ==> " (pprint result))
      result)))

;; Call like (drap macroexpand) for instance to log method calls.
;; TODO: Use $set! instead.
(defmacro dwrap (sym)
  (list 'def sym (list 'debugging-wrap (list 'quote sym) sym)))

;; Like let, but variable values are evaluated in an environment where
;; the newly defined variables already exist.  This allows for mutual
;; recursion between functions.  See SICP, page 390.
(defmacro labels (bindings &rest body)
  ;; `(let ,(map (lambda (binding)
  ;;               `(,(first binding) '*undefined*))
  ;;             bindings)
  ;;    ,@(map (lambda (binding)
  ;;             `($set! (first binding) (second binding))))
  ;;    ,@body)
  (append (list 'let
                (map (lambda (binding)
                       (list (first binding) ''*undefined*))
                     bindings))
          (map (lambda (binding)
                 (list '$set! (first binding) (second binding)))
               bindings)
          body))

;; Example: (with-asserts ((number? n)) (+ 1 n))
(defmacro with-asserts (asserts body)
  (reduce (lambda (b assertion)
            (list 'if assertion b
                  (list 'error '"Assertion failed: "
                        (list 'pprint (list 'quote assertion)))))
          asserts
          body))

)