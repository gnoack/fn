(
;; MACROS

;; Global variable *macros* stores a dictionary of all macros to be
;; applied to expressions before evaluation.  A macro is a lambda of
;; an expression and it's stored in the dictionary with the macro name
;; as key.

;; To bootstrap this:
;;  * introduce the *macros* dictionary using def,
;;  * introduce the defmacro macro ('defmacro . (lambda (e) ...))
;;    and define it so that it adds a macro to *macros*, in doubt by
;;    overriding.

(def macroexpand-defmacro
    (lambda (macroname lambda-list &rest body)
      ;; `(dict-put! *macros* (quote ,macroname)
      ;;             (lambda ,lambda-list ,@body))
      (list 'dict-put! '*macros* (list 'quote macroname)
            (cons 'lambda (cons lambda-list body)))))

(def *macros* (make-dict))
(dict-put! *macros* 'defmacro macroexpand-defmacro)

(def me-lambda-rec
    (lambda (xs)
      (cons 'lambda
      (cons (first xs) ; lambda-list
            (map macroexpand-rec (rest xs)))))) ; body

(def me-let-rec
    (lambda (xs)
      (cons 'let
      (cons (map (lambda (binding)
                   (cons (first binding)
                         (map macroexpand-rec (rest binding))))
                 (first xs)) ; bindings
            (map macroexpand-rec (rest xs))))))

(def false? (lambda (f) (eq false f)))

;; CAN'T USE ANY MACROS ITSELF!
; if, def are handled by regular function application rules
(def macroexpand-rec
    (lambda (e)
      (if (cons? e)
	  (let ((x (first e))
		(xs (rest e)))
	    (if (eq x 'quote) e  ; just leave it
	    (if (eq x 'lambda) (me-lambda-rec xs)
	    (if (eq x 'let) (me-let-rec xs)
              (if (if (symbol? x)
                      (dict-has-key? *macros* x)
                    false)
                  (macroexpand-rec (apply (dict-get *macros* x) xs))
                (cons x (map macroexpand-rec xs)))))))
	  e)))

;; 'macroexpand' is special in that the evaluator transforms any
;; expression with it before evaluating it.  This only happens though,
;; if macroexpand is actually defined.  As long as it's not defined,
;; no transformation is done.
(def macroexpand
    (lambda (e) (macroexpand-rec e)))

(defmacro cond (&rest pairs)
  (reduce (lambda (start item)
	    (let ((condition (first item))
		  (action (second item)))
	      (list 'if condition action start)))
	  (reverse pairs)
          '(error "No match.")))

(defmacro and (p &rest ps)
  (if (nil? ps) p
      (list 'if p (cons 'and ps) false)))

(defmacro or (p &rest ps)
  (if (nil? ps) p
      (list 'if p true (cons 'or ps))))

(defmacro defn (name lambda-list &rest body)
  ;; `(def ,name (lambda ,lambda-list ,@body))
  (list 'def name
	(cons 'lambda (cons lambda-list body))))

;;; ***********************************************************
;;; Quasiquote implementation
;;; ***********************************************************

(defn smatch? (symbol e)
  (and (cons? e)
       (eq symbol (first e))))

(defn list-expr? (e)
  (smatch? 'list e))

(defmacro quasiquote (expr)
  (%quasiquote expr))

(defn %simplify-listexpr (expr)
  (if (and (smatch? 'append expr)
           (all? list-expr? (rest expr)))
      (cons 'list (apply append (map rest (rest expr))))
    expr))

(defn %quasiquote (expr)
  (cond ((smatch? 'quasiquote expr) (list 'quote expr))
        ((smatch? 'unquote expr)    (second expr))
        ((list? expr)               (%simplify-listexpr
                                     (cons 'append (map %quasiquote-splice expr))))
        (true                       (list 'quote expr))))

(defn %quasiquote-splice (expr)
  (cond ((smatch? 'unquote expr)           (list 'list (second expr)))
	((smatch? 'unquote-splicing expr)  (second expr))
	(true                              (list 'list (list 'quasiquote expr)))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; More general purpose macros
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; TODO: Use with-gensyms for SYM_.
(defmacro case (expr &rest clauses)
  `(let ((sym_ ,expr))
     (cond
       ,@(map (lambda (clause)
                (cond ((list? (first clause))
                       `((eq (quote ,(first (first clause))) sym_)
                         ,(second clause)))
                      ((eq 'else (first clause))
                       `(true ,(second clause)))))
              clauses))))


;;; *******************************************************************
;;; Procedure call tracing for debugging
;;; *******************************************************************
;; TODO: Move this somewhere else!

;; TODO: We could use substrings of a larger indentation string instead.
(def %trace-indent "")

;; Wraps a method to print out its arguments.  (trace)
(defn debugging-wrap (func)
  (lambda (&rest args)
    (let ((old-indent %trace-indent))
      (set! %trace-indent (string-append "  " %trace-indent))
      (println %trace-indent (pprint (cons func args)))
      (let ((result (apply func args)))
        (println %trace-indent (pprint func) " returned " (pprint result))
        (set! %trace-indent old-indent)
        result))))

;; Call like (trace macroexpand) for instance to log method calls.
(defmacro trace (sym)
  `(set! ,sym (debugging-wrap ,sym)))

;; Like let, but variable values are evaluated in an environment where
;; the newly defined variables already exist.  This allows for mutual
;; recursion between functions.  See SICP, page 390.
(defmacro labels (bindings &rest body)
  `(let ,(map (lambda (binding)
                `(,(first binding) '*undefined*))
              bindings)
     ,@(map (lambda (binding)
              `(set! ,(first binding) ,(second binding)))
            bindings)
     ,@body))

;; Example: (with-asserts ((number? n)) (+ 1 n))
(defmacro with-asserts (asserts body)
  (reduce (lambda (b assertion)
            `(if ,assertion
                 ,b
               (error "Assertion failed: " (quote ,assertion))))
          (reverse asserts)
          body))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Macros for imperative code.                                      ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; TODO: Separate imperative macros into their own file?
(defmacro for-each ((var items) &rest cmds)
  `(map (lambda (,var) ,@cmds)
        ,items))

(defmacro add-to-list! (name value)
  `(set! ,name (cons ,value ,name)))

(defmacro flet (clauses &rest body)
  `(let ,(map (lambda ((name lambda-list &rest body))
                `(,name (lambda ,lambda-list ,@body)))
              clauses)
     ,@body))

;; One-sided `if' for imperative code.
(defmacro when (condition &rest statements)
  `(if ,condition
       (progn ,@statements)
     nil))

)