(
;; MACROS

;; Global variable *macros* stores an alist of all macros to be
;; applied to expressions before evaluation.  A macro is a lambda of
;; an expression and it's stored in the alist with the macro name as
;; key.

;; To bootstrap this:
;;  * introduce the *macros* alist using def,
;;  * introduce the defmacro macro ('defmacro . (lambda (e) ...))
;;    and define it so that it adds a macro to the *macros* alist, in
;;    doubt by overriding.  (We need an implementation of alists for
;;    that.)

(def macroexpand-defmacro
    (lambda (macroname lambda-list body)
      ;; `(def *macros* (acons ,macroname
      ;; 		     (lambda ,lambda-list ,body) *macros*))
      (list 'def '*macros*
	    (list 'acons (list 'quote macroname)
		  (list 'lambda lambda-list body) '*macros*))))

(def *macros*
    (acons 'defmacro
	   macroexpand-defmacro '()))

(def me-lambda-rec
    (lambda (xs)
      (cons 'lambda
      (cons (first xs) ; lambda-list
            (map macroexpand-rec (rest xs)))))) ; body

(def me-let-rec
    (lambda (xs)
      (cons 'let
      (cons (map (lambda (binding)
                   (cons (first binding)
                         (map macroexpand-rec (rest binding))))
                 (first xs)) ; bindings
            (map macroexpand-rec (rest xs))))))

(def false? (lambda (f) (eq false f)))

;; CAN'T USE ANY MACROS ITSELF!
; if, def are handled by regular function application rules
(def macroexpand-rec
    (lambda (e)
      (if (cons? e)
	  (let ((x (first e))
		(xs (rest e)))
	    (if (eq x 'quote) e  ; just leave it
	    (if (eq x 'lambda) (me-lambda-rec xs)
	    (if (eq x 'let) (me-let-rec xs)
		(let ((expand (lookup x *macros*)))
		  (if (not (false? expand))
		      (macroexpand-rec (apply expand xs))
		      (cons x (map macroexpand-rec xs))))))))
	  e)))

;; 'macroexpand' is special in that the evaluator transforms any
;; expression with it before evaluating it.  This only happens though,
;; if macroexpand is actually defined.  As long as it's not defined,
;; no transformation is done.
(def macroexpand
    (lambda (e) (macroexpand-rec e)))

(defmacro cond (&rest pairs)
  (reduce (lambda (start item)
	    (let ((condition (first item))
		  (action (second item)))
	      (list 'if condition action start)))
	  (reverse pairs)
	  '(error "No match.")))

(defmacro and (p &rest ps)
  (if (nil? ps) p
      (list 'if p (cons 'and ps) false)))

(defmacro or (p &rest ps)
  (if (nil? ps) p
      (list 'if p true (cons 'or ps))))

(defmacro defn (name lambda-list &rest body)
  ;; `(def ,name (lambda ,lambda-list ,@body))
  (list 'def name
	(cons 'lambda (cons lambda-list body))))

;;; ***********************************************************
;;; Quasiquote implementation
;;; ***********************************************************

(defn smatch? (symbol e)
  (and (cons? e)
       (eq symbol (first e))))

(defn list-expr? (e)
  (smatch? 'list e))

(defmacro quasiquote (expr)
  (%quasiquote expr))

(defn %simplify-listexpr (expr)
  (if (and (smatch? 'append expr)
           (all? list-expr? (rest expr)))
      (cons 'list (apply append (map rest (rest expr))))
    expr))

(defn %quasiquote (expr)
  (cond ((smatch? 'quasiquote expr) (list 'quote expr))
        ((smatch? 'unquote expr)    (second expr))
        ((list? expr)               (%simplify-listexpr
                                     (cons 'append (map %quasiquote-splice expr))))
        (true                       (list 'quote expr))))

(defn %quasiquote-splice (expr)
  (cond ((smatch? 'unquote expr)           (list 'list (second expr)))
	((smatch? 'unquote-splicing expr)  (second expr))
	(true                              (list 'list (list 'quasiquote expr)))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; More general purpose macros
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; TODO: Use with-gensyms for SYM_.
(defmacro case (expr &rest clauses)
  `(let ((sym_ ,expr))
     (cond
       ,@(map (lambda (clause)
                (cond ((list? (first clause))
                       `((eq (quote ,(first (first clause))) sym_)
                         ,(second clause)))
                      ((eq 'else (first clause))
                       `(true ,(second clause)))))
              clauses))))


;;; *******************************************************************
;;; Procedure call tracing for debugging
;;; *******************************************************************
;; TODO: Move this somewhere else!

;; TODO: We could use substrings of a larger indentation string instead.
(def %trace-indent "")

;; Wraps a method to print out its arguments.  (trace)
(defn debugging-wrap (func)
  (lambda (&rest args)
    (let ((old-indent %trace-indent))
      (set! %trace-indent (string-append "  " %trace-indent))
      (println %trace-indent (pprint (cons func args)))
      (let ((result (apply func args)))
        (println %trace-indent (pprint func) " returned " (pprint result))
        (set! %trace-indent old-indent)
        result))))

;; Call like (trace macroexpand) for instance to log method calls.
(defmacro trace (sym)
  `(set! ,sym (debugging-wrap ,sym)))

;; Like let, but variable values are evaluated in an environment where
;; the newly defined variables already exist.  This allows for mutual
;; recursion between functions.  See SICP, page 390.
(defmacro labels (bindings &rest body)
  `(let ,(map (lambda (binding)
                `(,(first binding) '*undefined*))
              bindings)
     ,@(map (lambda (binding)
              `(set! ,(first binding) ,(second binding)))
            bindings)
     ,@body))

;; Example: (with-asserts ((number? n)) (+ 1 n))
(defmacro with-asserts (asserts body)
  (reduce (lambda (b assertion)
            `(if ,assertion
                 ,b
               (error "Assertion failed: " (pprint (quote ,assertion)))))
          asserts
          body))

)