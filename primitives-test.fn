
(

;; Cons, first, rest
(eq 3 (first (cons 3 4)))
(eq 4 (rest (cons 3 4)))

;; Character conversion
(eq 65 (char->num #\A))
(eq #\A (num->char 65))

;; Symbol conversion.
(eq 'quuux (string->symbol "quuux"))
(eql "quuux" (symbol->string 'quuux))

;; Arithmetic primitives.
(eq 3 (+ 1 2))
(eq 12 (* 3 4))
(eq 3 (- 10 7))

;; Division.
(eq 3 (/ 12 4))
(eq 3 (/ 13 4))
(eq 3 (/ 14 4))
(eq 3 (/ 15 4))
(eq 0 (mod 12 4))
(eq 1 (mod 13 4))
(eq 2 (mod 14 4))
(eq 3 (mod 15 4))

;; Comparison
(integer<= 1 2)
(integer<= 42 42)

;; Primitive type predicates
; cons?
(cons? (cons 1 2))
(cons? "foo")  ; Strings are lists, too.
(not (cons? #\a))
(not (cons? 1))
(not (cons? 'foo))
; char?
(char? #\a)
(not (char? (cons 1 2)))
(not (char? 2))
(not (char? "foo"))
(not (char? 'foo))
; number?
(number? 3)
(not (number? (cons 1 2)))
(not (number? "foo"))
(not (number? #\a))
(not (number? 'foo))
;; symbol?
(symbol? 'something)
(not (symbol? (cons 1 2)))
(not (symbol? "xyz"))
(not (symbol? #\a))
(not (symbol? 3))

;; List

; TODO: Can be implemented in-lisp now.
(eq 2 (length (list 1 2)))
(eq 5 (nth (list 5 6) 0))
(eq 6 (nth (list 5 6) 1))

; Apply
(eql (list 1 2 3)
     (apply list (list 1 2 3)))
)
