;; Predicates on characters.
(defn digit? (c)
  (and (char? c)
       (char<= #\0 c #\9)))

(defn alpha? (c)
  (and (char? c)
       (char<= #\a c #\z)))

(defn char-predicate (x)
  (lambda (c)
    (and (char? c)
	 (eq x c))))

(defn whitespace? (c)
  (or (eq c #\Tab)
      (eq c #\Newline)
      (eq c #\Space)))

(defn peg= (item)
  (peg-terminal (lambda (x) (eq x item))))

(defn peg-string= (string)
  (apply peg-seq (map peg= (string->list string))))

;;; ==================================
;;; Grammar
;;; ==================================

;; Terminals
(def _any (peg-terminal ->true))
(def _digit (peg-terminal digit?))
(def _alpha (peg-terminal alpha?))

(def _dblquote (peg= #\"))
(def _hash (peg= #\#))
(def _backslash (peg= #\\))
(def _openparen (peg= #\())
(def _closeparen (peg= #\)))
(def _quote (peg= #\'))
(def _comma (peg= #\,))
(def _semicolon (peg= #\;))
(def _backquote (peg= #\`))
(def _at (peg= #\@))

(def _comment (peg-seq _semicolon
		       (peg* (peg-terminal (lambda (c) (not (eq c #\Newline)))))))

(def _whitespace (peg-alt _comment
			  (peg-terminal whitespace?)))

;; Indirection.
(defn _expr (input win lose)
  (_expr1 input win lose))

;; Rules

;; _integer ::= _digit+:ds  ==> (string->int (list->string ds))
(def _integer (peg=> (peg+ _digit) (lambda (x)
                                     (string->int (list->string x)))))

;; _escapedchar ::= '\' _any:e  ==> e
;;                | _any
(def _escapedchar
    (peg-alt (peg-let ((_ _backslash)
                       (e _any))
               e)
	     _any))

;; _string-char ::= ~'"' _escapedchar:c  ==> c
(def _string-char (peg-let ((_ (peg-not _dblquote))
                            (c _escapedchar))
                    c))

;; _string ::= '"' _string-char*:cs '"'  ==> (list->string cs)
(def _string (peg-let ((_a _dblquote)
                       (cs (peg* _string-char))
                       (_b _dblquote))
               (list->string cs)))

;; _separator ::= _whitespace | '(' | ')' | peg-empty
(def _separator (peg-alt _whitespace _openparen _closeparen peg-empty))

;; _anything_but_separator ::= ~_separator _any:e ==> e
(def _anything_but_separator
  (peg-let ((_ (peg-not _separator))
            (e _any))
    e))

;; _symbol ::= ~_hash _anything_but_separator+:x
;;             ==> (string->symbol (list->string x))
(def _symbol
  (peg-let ((_a  (peg-not _hash))
            (res (peg=> (peg+ _anything_but_separator)
                        (lambda (x) (string->symbol (list->string x))))))
    res))

;; Helper for _literal_escapedchar
(defn peg-result-string= (string result)
  (peg=> (peg-string= string) (lambda (x) result)))

;; _literal_escapedchar ::= ( "Newline" ==> #\Newline
;;                          | "Space" ==> #\Space
;;                          | "Tab" ==> #\Tab
;;                          | _any ):x ~_anything_but_separator  ==> x
(def _literal_escapedchar
  (peg-let ((x (peg-alt (peg-result-string= "Newline" #\Newline)
                        (peg-result-string= "Space" #\Space)
                        (peg-result-string= "Tab" #\Tab)
                        _anything_but_separator))
            (_ (peg-not (peg-not _separator))))
    x))

;; _character ::= '#' '\' _literal_escapedchar:c  ==> c
(def _character (peg-let ((_1 _hash)
                          (_2 _backslash)
                          (c  _literal_escapedchar))
                  c))

;; _whitespaces ::= _whitespace*
(def _whitespaces (peg* _whitespace))

;; _sexpression ::= '(' _expr*:es _whitespaces ')'  ==> es
(def _sexpression (peg-let ((_a  _openparen)
                            (res (peg* _expr))
                            (_b  _whitespaces)
                            (_c  _closeparen))
                    res))

;; _prefix_expr ::= '\'' _expr:e     ==> `(quote ,e)
;;                | '`' _expr:e      ==> `(backquote ,e)
;;                | ',' '@' _expr:e  ==> `(unquote-list ,e)
;;                | ',' _expr:e      ==> `(unquote ,e)
(def _prefix_expr
  ;; TODO: Fix these once quasiquote works properly.
  (peg-alt
   (peg-let ((_ _quote) (e _expr))
     (list 'quote e))
   (peg-let ((_ _backquote) (e _expr))
     (list 'quasiquote e))
   (peg-let ((_1 _comma) (_2 _at) (e _expr))
     (list 'unquote-splicing e))
   (peg-let ((_ _comma) (e _expr))
     (list 'unquote e))))

;; _expr1 ::= _whitespaces ( _prefix_expr
;;                         | _sexpression
;;                         | _integer
;;                         | _string
;;                         | _character
;;                         | _symbol ):e  ==> e
(def _expr1 (peg-let ((_  _whitespaces)
                      (e (peg-alt _prefix_expr
                                  _sexpression
                                  _integer
                                  _string
                                  _character
                                  _symbol)))
              e))

;; Used from pegs-parser
(def _lisp_expr _expr)

;; Public interface.
;; Returns a list of result, rest.
(defn read (in)
  (_expr in
	 list
	 error))

(defn read-and-check-empty-remainder (rule)
  (lambda (in)
    (rule (string->list in)
	  (lambda (result rest)
	    (if (all? whitespace? rest)
		result
	      (error "There's something left: " (list->string rest))))
	  error)))

(def read-one (read-and-check-empty-remainder _expr))
(def read-all (read-and-check-empty-remainder (peg* _expr)))
