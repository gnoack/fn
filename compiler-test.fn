
(

(eql '(let ((x 4)
            (y 8))
       (+ x y))
     (map-letdefinitions (lambda (x) (+ 3 x))
                         '(let ((x 1)
                                (y 5))
                           (+ x y))))

(eql '(+ 9 y)
     (replace-var '(+ x y) 'x 9))

; Don't replace beyond a let that redefines x
(eql '(+ 42 (let ((x 34)) x))
     (replace-var '(+ x (let ((x 34)) x)) 'x 42))

;; Variable environments
(->true
 (def %e empty-env)
 (def %xyz-env (empty-env 'with-vars 'x 'y 'z)))

(not (%e 'defines-immediately? 'x))
(%xyz-env 'defines-immediately? 'x)
(%xyz-env 'defines-immediately? 'z)
(not (%xyz-env 'defines-immediately? 'notthere))

(eq 0 (%e 'immediate-size))
(eq 3 (%xyz-env 'immediate-size))

; x shadows the old x.
(eq 5 ((%xyz-env 'with-vars 'a 'x) 'immediate-size))

(eql '(load-var 1) (%xyz-env 'generate-read 'x))
(eql '(load-var 2) (%xyz-env 'generate-read 'y))
(eql '(load-var 3) (%xyz-env 'generate-read 'z))

(eql '(load-value 123
       push)
     (compile 123 %e))

(eql '(load-value 99
       push
       load-value 42
       push
       load-var 1  ; first var
       push
       pop
       call 2)     ; 2 arguments
     (compile '(x 42 99) %xyz-env))

(->true (def global-label-counter 1000))
(eql '(load-var 1
       push
       pop
       jump-if-true true-branch-1001
       ; False branch
       load-value 0
       push
       jump after-if-1002
       ; True branch
       label true-branch-1001
       load-value 10
       push
       label after-if-1002)
     (compile '(if x 10 0) %xyz-env))

(eql '(load-value 42
       push
       pop
       save-var 1
       load-var 1
       push)
     (compile '(let ((x 42)) x) %e))

;; variables shadow existing variables with same name,
;; but the outer variables are still visible in the let clauses.
(eql '(load-var 1
       push
       pop
       save-var 4
       load-var 4
       push)
     (compile '(let ((x x)) x) %xyz-env))

)
