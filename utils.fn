
(

; TODO: Test.
(defn second (list)
  (first (rest list)))

(defn third (list)
  (first (rest (rest list))))

(defn fourth (list)
  (first (rest (rest (rest list)))))

(def last (lambda (l)
            (if (nil? (rest l))
                (first l)
                (last (rest l)))))

;; Progn
(def progn (lambda (&rest args)
             (last args)))

;; Appending

(defn append (&rest as)
  (if (nil? as) as
      (apply append-inner as)))

(defn append-inner (a &rest as)
  (if (nil? as) a
      (if (nil? a)
	  (apply append as)
	  (cons (first a)
		(apply append
		       (cons (rest a) as))))))

(defn digit->int (digit)
  (- (char->num digit) (char->num #\0)))

(defn string->int (str)
  (reduce (lambda (init next)
	    (+ (* 10 init) next))
	  (map digit->int str)
	  0))

(defn eql (a b)
  (if (and (cons? a) (cons? b))
      (and (eql (first a) (first b))
	   (eql (rest a) (rest b)))
      (eq a b)))

(defn nth (seq n)
  (if (cons? seq)
      (if (eq n 0)
	  (first seq)
	  (nth (rest seq) (- n 1)))
      nil))  ; Nothing found.

(defn length (seq)
  (if (cons? seq)
      (+ 1 (length (rest seq)))
      0))

;; Integer to string conversion.
(def _hex-digits "0123456789abcef")
(defn _int->string (n base)
  (if (eq n 0)
      (list)
      (cons (nth _hex-digits (mod n base))
	    (_int->string (/ n base) base))))

(defn int->string (n base)
  (reverse (_int->string n base)))


;; Ordering operators.

(defn <= (&rest args)
  (sequence-ordered? integer<= args))

(defn char<= (&rest args)
  (sequence-ordered? integer<=
		     (map char->num args)))

(defn binary< (x y)
  (_and (<= x y)
	(not (eq x y))))

(defn < (&rest args)
  (sequence-ordered? binary< args))


;; Checks that for each pair of neighbor
;; elements a, b in the sequence,
;; (in-order? a b) holds.
(defn sequence-ordered? (in-order? seq)
  (cond ((nil? seq) true)
	((nil? (rest seq)) true)
	(true 
	 (and (in-order? (first seq)
			 (first (rest seq)))
	      (sequence-ordered?
	       in-order? (rest seq))))))

; Right-reducing. (a (b (c end)))
(defn reduce-right (combine seq end)
  (if (nil? seq)
      end
      (combine (first seq)
	       (reduce-right combine
			     (rest seq)
			     end))))

;; Always return true (false).
(defn ->true (&rest args) true)
(defn ->false (&rest args) false)

;; True iff the list contains only true.
(defn all? (list)
  (reduce (lambda (a b) (and a b)) list true))

;; True iff the list contains true at least once.
(defn any? (list)
  (reduce (lambda (a b) (or a b)) list false))

(defn list? (potential-list)
  (or (nil? potential-list)
      (and (cons? potential-list)
           (list? (rest potential-list)))))

(defn error (&rest args)
  (progn
    (apply awriteout
	   (cons "*ERROR*: " (map pprint args)))
    (kill-lisp 1)))
)