
;; Relying on first, rest, cons
;; Relying on char->num num->char
;; + -

(

(def nil? (lambda (x)
	    (eq nil x)))

(def map (lambda (proc sequence)
	   (if (nil? sequence)
	       sequence
	       (cons (proc (first sequence))
		     (map proc (rest sequence))))))

(def reduce (lambda (proc list start)
	      (if (nil? list)
		  start
		  (reduce proc
			  (rest list)
			  (proc start (first list))))))

(def digit->int (lambda (digit)
		  (- (char->num digit) (char->num #\0))))

(def string->int (lambda (str)
		   (reduce (lambda (init next)
			     (+ (* 10 init) next))
			   (map digit->int str)
			   0)))

(def not (lambda (a)
	   (if a false true)))

(def and (lambda (a b)
	   (if a b false)))

(def eql (lambda (a b)
	   (if (and (cons? a) (cons? b))
	       (and (eql (first a) (first b))
		    (eql (rest a) (rest b)))
	       (eq a b))))

(def nth
    (lambda (seq n)
      (if (cons? seq)
	  (if (eq n 0)
	      (first seq)
	      (nth (rest seq) (- n 1)))
	  nil)))  ; Nothing found.

(def length
    (lambda (seq)
      (if (cons? seq)
	  (+ 1 (length (rest seq)))
	  0)))

;; Reversing sequences.
(def _reverse
    (lambda (seq acc)
      (if (cons? seq)
	  (_reverse (rest seq)
		    (cons (first seq) acc))
	  acc)))

(def reverse
    (lambda (seq) (_reverse seq nil)))

;; Integer to string conversion.
(def _hex-digits "0123456789abcef")
(def _int->string
    (lambda (n base)
      (if (eq n 0)
	  (list)
	  (cons (nth _hex-digits (mod n base))
		(_int->string (/ n base) base)))))

(def int->string
    (lambda (n base)
      (reverse (_int->string n base))))

)