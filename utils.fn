
(

(defn identity (x) x)

(defn second (list)  (first (rest list)))
(defn third (list)   (first (rest (rest list))))
(defn fourth (list)  (first (rest (rest (rest list)))))

(defn last (l)
  (if (nil? (rest l))
      (first l)
      (last (rest l))))

;; Progn
(defn progn (&rest args)
  (last args))

;; Lists
(defn append (&rest as)
  (if (nil? as) as
      (apply append-inner as)))

(defn append-inner (a &rest as)
  (if (nil? as) a
      (if (nil? a)
	  (apply append as)
	  (cons (first a)
		(apply append
		       (cons (rest a) as))))))

(defn eql (a b)
  (if (and (cons? a) (cons? b))
      (and (eql (first a) (first b))
	   (eql (rest a) (rest b)))
      (eq a b)))

(defn nth (seq n)
  (if (cons? seq)
      (if (eq n 0)
	  (first seq)
	  (nth (rest seq) (- n 1)))
      nil))  ; Nothing found.

(defn length (seq)
  (if (cons? seq)
      (+ 1 (length (rest seq)))
      0))

;;;; Strings
(defn string? (str)
  (and (cons? str)
       (all? (map char? str))))

(def string-append append)

(defn string-size (str) (length str))

(defn string-at (str n)
  (if (and (<= 0 n)
           (< n (string-size str)))
      (nth str n)
      (error "Out of bounds.")))

(defn %string->list-inner (str n str-length)
  (if (eq n str-length)
      (list)
      (cons (string-at str n)
            (%string->list-inner str (+ n 1) str-length))))

(defn string->list (str)
  (%string->list-inner str 0 (string-size str)))

(def list->string identity)
(def string= eql)

(defn map-string (fn str)
  (map fn (string->list str)))

(defn string-join (strings delimiter)
  (if (cons? strings)
      (apply string-append
	     (cons (first strings)
		   (map (lambda (s) (string-append delimiter s))
			(rest strings))))
      '()))

;; Number conversions
(defn digit->int (digit)
  (- (char->num digit) (char->num #\0)))

(defn string->int (str)
  (reduce (lambda (init next)
	    (+ (* 10 init) next))
	  (map digit->int (string->list str))
	  0))

;; Integer to string conversion.
(def _hex-digits "0123456789abcef")
(defn _int->string (n base)
  (if (eq n 0)
      (list)
      (cons (nth _hex-digits (mod n base))
	    (_int->string (/ n base) base))))

(defn int->string (n base)
  (reverse (_int->string n base)))


;; Ordering operators.

(defn <= (&rest args)
  (sequence-ordered? integer<= args))

(defn char<= (&rest args)
  (sequence-ordered? integer<=
		     (map char->num args)))

(defn binary< (x y)
  (_and (<= x y)
	(not (eq x y))))

(defn < (&rest args)
  (sequence-ordered? binary< args))


;; Checks that for each pair of neighbor
;; elements a, b in the sequence,
;; (in-order? a b) holds.
(defn sequence-ordered? (in-order? seq)
  (cond ((nil? seq) true)
	((nil? (rest seq)) true)
	(true 
	 (and (in-order? (first seq)
			 (first (rest seq)))
	      (sequence-ordered?
	       in-order? (rest seq))))))

; Right-reducing. (a (b (c end)))
(defn reduce-right (combine seq end)
  (if (nil? seq)
      end
      (combine (first seq)
	       (reduce-right combine
			     (rest seq)
			     end))))

;; Always return true (false).
(defn ->true (&rest args) true)
(defn ->false (&rest args) false)

;; True iff the list contains only true.
(defn all? (list)
  (reduce (lambda (a b) (and a b)) list true))

;; True iff the list contains true at least once.
(defn any? (list)
  (reduce (lambda (a b) (or a b)) list false))

(defn list? (potential-list)
  (or (nil? potential-list)
      (and (cons? potential-list)
           (list? (rest potential-list)))))

(defn error (&rest args)
  (progn
    (apply awriteout
	   (cons "*ERROR*: " (map pprint args)))
    (kill-lisp 1)))

)