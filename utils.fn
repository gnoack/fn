
(

; TODO: Test.
(defn second (list)
  (first (rest list)))

(defn third (list)
  (first (rest (rest list))))

(defn fourth (list)
  (first (rest (rest (rest list)))))

;; Appending

(defn append (a &rest as)
  (if (nil? as) a
      (if (nil? a)
	  (apply append as)
	  (cons (first a)
		(apply append
		       (cons (rest a) as))))))

(defn digit->int (digit)
  (- (char->num digit) (char->num #\0)))

(defn string->int (str)
  (reduce (lambda (init next)
	    (+ (* 10 init) next))
	  (map digit->int str)
	  0))

(defn eql (a b)
  (if (and (cons? a) (cons? b))
      (and (eql (first a) (first b))
	   (eql (rest a) (rest b)))
      (eq a b)))

(defn nth (seq n)
  (if (cons? seq)
      (if (eq n 0)
	  (first seq)
	  (nth (rest seq) (- n 1)))
      nil))  ; Nothing found.

(defn length (seq)
  (if (cons? seq)
      (+ 1 (length (rest seq)))
      0))

;; Integer to string conversion.
(def _hex-digits "0123456789abcef")
(defn _int->string (n base)
  (if (eq n 0)
      (list)
      (cons (nth _hex-digits (mod n base))
	    (_int->string (/ n base) base))))

(defn int->string (n base)
  (reverse (_int->string n base)))


;; Ordering operators.

(defn <= (&rest args)
  (sequence-ordered? integer<= args))

(defn char<= (&rest args)
  (sequence-ordered? integer<=
		     (map char->num args)))

(defn binary< (x y)
  (_and (<= x y)
	(not (eq x y))))

(defn < (&rest args)
  (sequence-ordered? binary< args))


;; Checks that for each pair of neighbor
;; elements a, b in the sequence,
;; (in-order? a b) holds.
(defn sequence-ordered? (in-order? seq)
  (cond ((nil? seq) true)
	((nil? (rest seq)) true)
	(true 
	 (and (in-order? (first seq)
			 (first (rest seq)))
	      (sequence-ordered?
	       in-order? (rest seq))))))

; Right-reducing. (a (b (c end)))
(defn reduce-right (combine seq end)
  (if (nil? seq)
      end
      (combine (first seq)
	       (reduce-right combine
			     (rest seq)
			     end))))

;; String concatenation
(defn string-concat-binary (str1 str2)
  (if (nil? str1)
      str2
      (cons (first str1) (string-concat-binary (rest str1) str2))))

; TODO: Reuse this for list concatenation as well.
(defn string-concat (&rest strings)
  (reduce-right string-concat-binary strings '()))

;; Always return true (false).
(defn ->true (&rest args) true)
(defn ->false (&rest args) false)

;; True iff the list contains only true.
(defn all? (list)
  (reduce (lambda (a b) (and a b)) list true))

;; True iff the list contains true at least once.
(defn any? (list)
  (reduce (lambda (a b) (or a b)) list false))

;; Range
;; TODO: This is not an entirely well-thought implementation.
(defn %range (size acc)
  (if (eq size 0)
      (cons 0 acc)
      (%range (- size 1) (cons size acc))))

(defn range (size)
  (if (eq size 0)
      (list)
      (%range (- size 1) '())))

;; Map2, maps objects of two lists at once.
(defn map2 (proc l1 l2)
  (cond ((and (cons? l1) (cons? l2))
	 (cons (proc (first l1) (first l2))
	       (map2 proc (rest l1) (rest l2))))
	((or (nil? l1) (nil? l2))
	 '())
	(true
	 (error "Should not happen -- this was not a list."))))

(defn list? (potential-list)
  (or (nil? potential-list)
      (and (cons? potential-list)
           (list? (rest potential-list)))))

(defn error (&rest args)
  (progn
    (apply awriteout
	   (cons "*ERROR*: " (map pprint args)))
    (kill-lisp 1)))
)