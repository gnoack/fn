
(

(defn last (l)
  (if (nil? (rest l))
      (first l)
      (last (rest l))))

;; Progn
(defn progn (&rest args)
  (last args))

;; Lists
(defn length (seq)
  (if (cons? seq)
      (+ 1 (length (rest seq)))
      0))

(defn eql (a b)
  (cond ((and (cons? a) (cons? b))
         (and (eql (first a) (first b))
              (eql (rest a) (rest b))))
        ((and (string? a) (string? b))
         (string= a b))
        (true
         (eq a b))))

;; TODO: For speed, write in C using memcmp().
(defn $mem= (a a-offset b b-offset size)
  (or (eq 0 size)
      (and (eq ($mem-block-byte-get a a-offset)
               ($mem-block-byte-get b b-offset))
           ($mem= a (+ 1 a-offset)
                  b (+ 1 b-offset)
                  (- size 1)))))

;; TODO: For speed, write in C using memcpy().
(defn $memcpy (trg trg-offset src src-offset size)
  (if (eq 0 size)
      trg
      (progn
        ($mem-block-byte-set! trg trg-offset
                              ($mem-block-byte-get src src-offset))
        ($memcpy trg (+ 1 trg-offset)
                 src (+ 1 src-offset)
                 (- size 1)))))

(defn $mem-populate-from-byte-list (trg trg-offset src-list)
  (if (cons? src-list)
      (progn
        ($mem-block-byte-set! trg trg-offset (first src-list))
        ($mem-populate-from-byte-list trg (+ 1 trg-offset) (rest src-list)))
      trg))

;;; Strings
(defn list->string (src-list)
  (let ((len (length src-list)))
    (let ((result-raw ($make-mem-block len)))
      ($mem-populate-from-byte-list result-raw 0 (map char->num src-list))
      ($make @string len 0 result-raw))))

(defn string-append (&rest as)
  (let ((total-string-size (reduce + (map string-size as) 0)))
    (let ((result-raw ($make-mem-block total-string-size)))
      ($mem-populate-from-string-list result-raw 0 as)
      ($make @string total-string-size 0 result-raw))))

(defn $mem-populate-from-string-list (trg trg-offset strings)
  (if (nil? strings)
      trg
      (let ((src-string (first strings)))
        ($memcpy trg trg-offset
                 (%string-raw src-string) (%string-offset src-string)
                 (string-size src-string))
        ($mem-populate-from-string-list
         trg (+ trg-offset (string-size src-string))
         (rest strings)))))

(defn string? (str)        (eq @string (type-of str)))
(defn string-size (str)    ($mem-get str 1))
(defn %string-offset (str) ($mem-get str 2))
(defn %string-raw (str)    ($mem-get str 3))

(defn string-at (str n)
  (with-asserts ((string? str)
                 (<= 0 n (- (string-size str) 1)))
    (num->char ($mem-block-byte-get (%string-raw str)
                                    (+ (%string-offset str) n)))))

(defn %string->list-inner (str n str-length)
  (if (eq n str-length)
      (list)
      (cons (string-at str n)
            (%string->list-inner str (+ n 1) str-length))))

(defn string->list (str)
  (with-asserts ((string? str))
    (%string->list-inner str 0 (string-size str))))

(defn string= (a b)
  (with-asserts ((string? a)
                 (string? b))
    (and (eq (string-size a) (string-size b))
         ($mem= (%string-raw a) (%string-offset a)
                (%string-raw b) (%string-offset b)
                (string-size a)))))

(defn map-string (fn str)
  (map fn (string->list str)))

(defn string-join (strings delimiter)
  (if (cons? strings)
      (apply string-append
	     (cons (first strings)
		   (map (lambda (s) (string-append delimiter s))
			(rest strings))))
      ""))

(defn substring (str begin)
  (with-asserts ((<= begin (string-size str)))
    ($make @string
           (- (string-size str) begin)
           (+ (%string-offset str) begin)
           (%string-raw str))))

;; Number conversions
(defn digit->int (digit)
  (- (char->num digit) (char->num #\0)))

(defn string->int (str)
  (reduce (lambda (init next)
	    (+ (* 10 init) next))
	  (map digit->int (string->list str))
	  0))

;; Integer to string conversion.
(def _hex-digits "0123456789abcdef")
(defn _int->string (n base)
  (if (eq n 0)
      (list)
      (cons (string-at _hex-digits (mod n base))
	    (_int->string (/ n base) base))))

(defn int->string (n base)
  (list->string (reverse (_int->string n base))))


;; Ordering operators.

(defn <= (&rest args)
  (sequence-ordered? integer<= args))

(defn char<= (&rest args)
  (sequence-ordered? integer<=
		     (map char->num args)))

(defn binary< (x y)
  (and (<= x y)
       (not (eq x y))))

(defn < (&rest args)
  (sequence-ordered? binary< args))


;; Checks that for each pair of neighbor
;; elements a, b in the sequence,
;; (in-order? a b) holds.
(defn sequence-ordered? (in-order? seq)
  (cond ((nil? seq) true)
	((nil? (rest seq)) true)
	(true 
	 (and (in-order? (first seq)
			 (first (rest seq)))
	      (sequence-ordered?
	       in-order? (rest seq))))))

; Right-reducing. (a (b (c end)))
(defn reduce-right (combine seq end)
  (if (nil? seq)
      end
      (combine (first seq)
	       (reduce-right combine
			     (rest seq)
			     end))))

;; Always return true (false).
(defn ->true (&rest args) true)
(defn ->false (&rest args) false)

(defn error (&rest args)
  (apply awriteout (cons "*ERROR*: " (map pprint args)))
  (kill-lisp 1))

)