;; Everything is prefixed _PP, to avoid namespace collisions.

(def _pp_optional_whitespaces (peg* _whitespace))

(defn _pp_token (rule)
  (peg-let ((_ _pp_optional_whitespaces)
            (r rule)
            (_ _pp_optional_whitespaces))
    r))

(def _pp_singlequote (peg= #\'))
(def _pp_colon (peg= #\:))

(def _pp_semicolon (_pp_token (peg= #\;)))
(def _pp_arrow (_pp_token (peg-string= "=>")))
(def _pp_define (_pp_token (peg-string= "::=")))
(def _pp_grammar_keyword (_pp_token (peg-string= "grammar")))
(def _pp_opencurly (_pp_token (peg= #\{)))
(def _pp_closecurly (_pp_token (peg= #\})))
(def _pp_openbracket (_pp_token (peg= #\()))
(def _pp_closebracket (_pp_token (peg= #\))))
(def _pp_negation_sign (_pp_token (peg= #\~)))

;; Indirection for recursive calls.
(defn _pp_expr (input win lose)
  (_pp_expr1 input win lose))

;; TODO: Should be like lisp symbol, but also take
;; into account the separators in the grammar language.
(def _pp_symbol
  (peg=> (peg+ _alpha)
         (lambda (l) (string->symbol (list->string l)))))

(def _pp_string-expr
  (peg-let ((_ _pp_optional_whitespaces)
            (s _string))  ; Like in Lisp.
    `(peg-seq ,@(map (lambda (ch) `(peg= ,ch))
                     (string->list s)))))

(def _pp_symbol-expr
  (peg-let ((_ _pp_optional_whitespaces)
            (_ _pp_singlequote)
            (s _pp_symbol))  ; Like in Lisp.
    `(peg= (quote ,s))))

(def _pp_invocation-expr
  (peg-let ((_ _pp_optional_whitespaces)
            (s _pp_symbol))  ; Like in Lisp.
    `(invoke ,s)))

(def _pp_bracketed-expr
  (peg-let ((_ _pp_openbracket)
            (e _pp_expr)
            (_ _pp_closebracket))
    e))

;; Forward declaration for recursive call.
(defn _pp_expr4_indirect (input win lose)
  (_pp_expr4 input win lose))

(def _pp_negated-expr
  (peg-let ((_ _pp_negation_sign)
            (e _pp_expr4_indirect))
    `(peg-not ,e)))

;; An individual parsing expression.
(def _pp_expr4 (peg-alt _pp_negated-expr
                        _pp_string-expr
                        _pp_symbol-expr
                        _pp_invocation-expr
                        _pp_bracketed-expr))

;; Just parse nothing, always succeeds.
(def _pp_epsilon (peg-seq))

(def _pp_plus_expr
  (peg-let ((e _pp_expr4)
            (_ (peg= #\+)))
    (list 'peg+ e)))

(def _pp_star_expr
  (peg-let ((e _pp_expr4)
            (_ (peg= #\*)))
    (list 'peg* e)))

(def _pp_expr3
  (peg-alt _pp_plus_expr
           _pp_star_expr
           _pp_expr4))

;; _pp_bindingvar ::=
;;     ':' _symbol:s  => s
;;   | _pp_epsilon    => '_
(def _pp_bindingvar
  (peg-alt (peg-let ((_ _pp_colon)
                     (s _symbol))  ; like in Lisp.
             s)
           (peg=> _pp_epsilon
                  (lambda (x) '_))))

;; Parser for a list of items separated by a separator.
(defn peg-listof+ (item sep)
  (peg-let ((a  item)
            (as (peg* (peg-let ((_ sep) (it item))
                        it))))
    (cons a as)))

(defn peg-listof* (item sep)
  (peg-alt
   (peg-listof+ item sep)
   (peg-seq)))

;; _pp_binding ::= _pp_expr3:e _pp_bindingvar:v => (list v e)
(def _pp_binding
  (peg-let ((e _pp_expr3)
            (v _pp_bindingvar))
    (list v e)))

(def _pp_action_sequence
  (peg-let ((bindings (peg-listof+ _pp_binding
                                   _pp_optional_whitespaces))
            (_ _pp_arrow)
            (action _lisp_expr))
    (list 'peg-let bindings action)))

(def _pp_sequence
  (peg=> (peg+ (_pp_token _pp_expr3))
         (lambda (x) `(peg-seq ,@x))))

;; An action with bound variables.
(def _pp_expr2
  (peg-alt _pp_action_sequence
           _pp_sequence))

(def _pp_expr1
  (peg=> (peg-listof+ _pp_expr2 (_pp_token (peg= #\|)))
         (lambda (x)
           (cons 'peg-alt x))))

;; _pp_rule ::= _pp_symbol:n "::=" _pp_expr1:e  => `(rule ,n ,e)
(def _pp_rule
  (peg-let ((_    _pp_optional_whitespaces)
            (name _pp_symbol)
            (_    _pp_define)
            (expr _pp_expr1))
    `(defrule ,name ,expr)))

(def _pp_grammar
  (peg-let ((_  _pp_optional_whitespaces)
            (_  _pp_grammar_keyword)
            (n  _pp_symbol)
            (_  _pp_opencurly)
            (rs (peg-listof* _pp_rule _pp_semicolon))
            (_  _pp_closecurly))
    `(defgrammar ,n ,@rs)))
