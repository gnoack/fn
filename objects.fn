(

;;;; ********************************
;;;; Types
;;;; ********************************

;; The type type links to itself: @type = ($make @type type?)
(def @type ($make 'foo 'bar))
(defn type? (x)
  (eq (type-of x) @type))
($set @type 0 @type)
($set @type 1 type?)

(def @mem ($make @type mem?))

; @cons must be created early for consing,
; so we need some retroactive patching.
;(def @cons ($make @type cons?))
($set @cons 0 @type)
($set @cons 1 cons?)

(defmacro deftype (name tester)
  (list 'def name
	(list '$make '@type tester)))

(deftype @smallint number?)
(deftype @character char?)
(deftype @symbol symbol?)
(deftype @nil nil?)

;; Hardcoded for half-primitive values like integers,
;; characters, nil and so forth.  For higher-level,
;; memory-allocated values, the value at position 0
;; is used as type.
(defn type-of (x)
  (cond ((number? x) @smallint)
	((char? x) @character)
	((symbol? x) @symbol)
	((nil? x) @nil)
	((mem? x) ($get x 0))))



;;;; *****************************************
;;;; Simple OO using symbol-based dispatching.
;;;; *****************************************

(defn dispatch-clause->cond-clause (clause)
  (list (list 'eq (first clause) 'selector)
	(list 'lambda (second clause) (third clause))))

;; Constructs an object with identity and able to receive messages.
(defmacro dispatcher (name &rest defs)
  ;; `(labels ((,name (lambda (selector &rest args)
  ;;                    (apply (cond ,(map dispatch-clause->cond-clause defs))
  ;;                           args))))
  ;;    ,name)
  (list 'labels
	(list (list name
		    (list 'lambda (list 'selector '&rest 'args)
			  (list 'apply
				(cons 'cond (map dispatch-clause->cond-clause defs))
				'args))))
	name))

;; Like apply, but for sending messages.
(defn send (receiver message arguments)
  (apply receiver (cons message arguments)))



)