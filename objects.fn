(

;;;; ********************************
;;;; Types
;;;; ********************************

;; The type type links to itself: @type = ($make @type empty-map)
(def @type ($make 1 2))
($set @type 0 @type)
($set @type 1 empty-map)
(defn type? (x)
  (eq (type-of x) @type))

; @cons must be created early for consing,
; so we need some retroactive patching.
;(def @cons ($make @type cons? empty-map))
($set @cons 0 @type)
($set @cons 1 empty-map)

;; TODO: Supertypes?
(defmacro deftype (name)
  (list 'def name
	(list '$make '@type 'empty-map)))

(deftype @mem)
(deftype @smallint)
(deftype @character)
(deftype @symbol)
(deftype @nil)

;; Hardcoded for half-primitive values like integers,
;; characters, nil and so forth.  For higher-level,
;; memory-allocated values, the value at position 0
;; is used as type.
(defn type-of (x)
  (cond ((number? x) @smallint)
	((char? x) @character)
	((symbol? x) @symbol)
	((nil? x) @nil)
	((mem? x) ($get x 0))))


;;; Method definition

(defn install-method! (type selector method)
  ($set type 1
        (send ($get type 1) 'put selector method)))

(defmacro defm (type selector args body)
  ;; `(install-method! ,type ,selector
  ;;                   (lambda (self ,@args) ,body))
  (list 'install-method! type selector
        (list 'lambda (cons 'self args) body)))


;;; Message sending

(defn %method-for-type (type selector)
  (send ($get type 1) 'get selector))

(defn send (receiver message &rest arguments)
  (if (procedure? receiver)
      (apply receiver (cons message arguments))
      (apply (%method-for-type (type-of receiver) message) (cons receiver arguments))))

;; Like apply, but for sending messages.
(defn send-apply (receiver message arguments)
  (apply send (cons receiver (cons message arguments))))

)
