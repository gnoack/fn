(

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Types                                                          ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; The type type links to itself: @type = ($make @type (make-dict))
(def @type ($make 1 2))
($mem-set! @type 0 @type)
($mem-set! @type 1 (make-dict))
(defn type? (x)
  (eq (type-of x) @type))

; @cons and others must be created early for object creation from C,
; so we need some retroactive patching.  Idea is still this:
;  (def @cons ($make @type (make-dict)))
(defn $patch-type! (type)
  ($mem-set! type 0 @type)
  ($mem-set! type 1 (make-dict)))

($patch-type! @array)
($patch-type! @cons)
($patch-type! @dict)
($patch-type! @frame)
($patch-type! @string)
($patch-type! @symbol)

; Same procedure for @procedure.
($patch-type! @procedure)
($patch-type! @native-procedure)
($patch-type! @compiled-procedure)

;; TODO: Supertypes?
(defmacro deftype (name)
  `(def ,name ($make @type (make-dict))))

(deftype @mem)
(deftype @smallint)
(deftype @character)
(deftype @nil)
(deftype @mem-block)

;; Hardcoded for half-primitive values like integers,
;; characters, nil and so forth.  For higher-level,
;; memory-allocated values, the value at position 0
;; is used as type.
(defn type-of (x)
  (cond ((number? x) @smallint)
	((char? x) @character)
	((symbol? x) @symbol)
	((nil? x) @nil)
        ((mem-block? x) @mem-block)
	((mem? x) ($mem-get x 0))))


;;; Method definition

(defn install-method! (type selector method)
  (with-asserts ((type? type))
    (dict-put! ($mem-get type 1) selector method)))

(defmacro defm (type selector args body)
  `(install-method! ,type ,selector
                    (lambda (self ,@args) ,body)))


;;; Message sending

(defn send (receiver message &rest arguments)
  (defn %method-for-type (type selector)
    (dict-get ($mem-get type 1) selector))
  (if (procedure? receiver)
      (apply receiver (cons message arguments))
      (apply (%method-for-type (type-of receiver) message)
             (cons receiver arguments))))

;; Like apply, but for sending messages.
(defn send-apply (receiver message arguments)
  (apply send (cons receiver (cons message arguments))))

(defn sender (message)
  (lambda (receiver &rest args)
    (send-apply receiver message args)))

)
