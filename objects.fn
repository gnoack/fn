(

(defn %accessor-defn (fieldname index tester)
  (list 'defn fieldname (list 'obj)
	(list 'if (list tester 'obj)
	      (list '$get 'obj index)
	      (list 'error))))

;; TODO: Use regular @-prefixed type as type tag!
(defn %define-struct (name fields)
  (let ((namestr (symbol->string name)))
    ;; `(->true
    ;;    (defn
    ;;      ,(string->symbol (append "make-" namestr))
    ;;      ,fields
    ;;      ($make (quote ,name) ,@fields))
    ;;    (defn
    ;;      ,(string->symbol (append namestr "?"))
    ;;      (obj)
    ;;      (eq (quote ,name) ($get obj 0)))
    ;;    (->true ,@(map2 (lambda (fieldname index)
    ;;                       (%accessor-defn fieldname (+1 index)
    ;;                       (string->symbol (append namestr "?")))
    ;;                    fields (range (length fields)))))
    (list '->true
	  (list 'defn
		(string->symbol (append "make-" namestr))
		fields
		(cons '$make (cons (list 'quote name) fields)))
	  (list 'defn
		(string->symbol (append namestr "?"))
		(list 'obj)
		(list 'eq (list 'quote name) (list '$get 'obj 0)))
	  (cons '->true
		(map2 (lambda (fieldname index)
			(%accessor-defn
			 fieldname (+ 1 index)
			 (string->symbol (append namestr "?"))))
			fields (range (length fields))))
	  )))

(defmacro defstruct (name fields)
  (%define-struct name fields))


;;;; ********************************
;;;; Types
;;;; ********************************

;; The type type links to itself: @type = ($make @type type?)
(def @type ($make 'foo 'bar))
(defn type? (x)
  (eq (type-of x) @type))
($set @type 0 @type)
($set @type 1 type?)

(def @mem ($make @type mem?))

; @cons must be created early for consing,
; so we need some retroactive patching.
;(def @cons ($make @type cons?))
($set @cons 0 @type)
($set @cons 1 cons?)

(defmacro deftype (name tester)
  (list 'def name
	(list '$make '@type tester)))

(deftype @smallint number?)
(deftype @character char?)
(deftype @symbol symbol?)
(deftype @nil nil?)

;; Hardcoded for half-primitive values like integers,
;; characters, nil and so forth.  For higher-level,
;; memory-allocated values, the value at position 0
;; is used as type.
(defn type-of (x)
  (cond ((number? x) @smallint)
	((char? x) @character)
	((symbol? x) @symbol)
	((nil? x) @nil)
	((mem? x) ($get x 0))))



;;;; *****************************************
;;;; Simple OO using symbol-based dispatching.
;;;; *****************************************

(defn dispatch-clause->cond-clause (clause)
  (list (list 'eq (first clause) 'selector)
	(list 'lambda (second clause) (third clause))))

;; Constructs an object with identity and able to receive messages.
(defmacro dispatcher (name &rest defs)
  ;; `(labels ((,name (lambda (selector &rest args)
  ;;                    (apply (cond ,(map dispatch-clause->cond-clause defs))
  ;;                           args))))
  ;;    ,name)
  (list 'labels
	(list (list name
		    (list 'lambda (list 'selector '&rest 'args)
			  (list 'apply
				(cons 'cond (map dispatch-clause->cond-clause defs))
				'args))))
	name))

;; Like apply, but for sending messages.
(defn send (receiver message arguments)
  (apply receiver (cons message arguments)))



)